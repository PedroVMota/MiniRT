diff --git a/.DS_Store b/.DS_Store
index 0c69e70..ef35a48 100644
Binary files a/.DS_Store and b/.DS_Store differ
diff --git a/Libft/libft.h b/Libft/libft.h
index e189c42..892f77c 100644
--- a/Libft/libft.h
+++ b/Libft/libft.h
@@ -3,10 +3,10 @@
 /*                                                        :::      ::::::::   */
 /*   libft.h                                            :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
+/*   By: pvital-m <pvital-m@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2023/12/04 21:56:44 by oharoon           #+#    #+#             */
-/*   Updated: 2024/02/12 17:11:32 by pedro            ###   ########.fr       */
+/*   Updated: 2023/12/23 22:57:55 by pvital-m         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -107,7 +107,7 @@ void				*ft_memchr(const void *s, int c, size_t n);
 void				*ft_calloc(size_t count, size_t size);
 long				ft_atoi(const char *str);
 void				ft_bzero(void *s, size_t n);
-double				ft_atof(char *str);
+double				ft_atof(const char *str);
 int					ft_isalpha(int c);
 int					ft_isascii(int c);
 int					ft_isdigit(int a);
diff --git a/Libft/utils/Makefile b/Libft/utils/Makefile
index 2f3f262..31c8e90 100755
--- a/Libft/utils/Makefile
+++ b/Libft/utils/Makefile
@@ -6,7 +6,7 @@
 #    By: pedro <pedro@student.42.fr>                +#+  +:+       +#+         #
 #                                                 +#+#+#+#+#+   +#+            #
 #    Created: 2023/03/05 14:49:36 by pvital-m          #+#    #+#              #
-#    Updated: 2024/02/12 17:11:17 by pedro            ###   ########.fr        #
+#    Updated: 2024/01/21 19:13:36 by pedro            ###   ########.fr        #
 #                                                                              #
 # **************************************************************************** #
 
@@ -31,7 +31,7 @@ SRCS	= 	./src/ft_isalpha.c ./src/ft_isdigit.c ./src/ft_isalnum.c ./src/ft_isasci
 			./src/ft_putstr_fd.c ./src/ft_putendl_fd.c ./src/ft_putnbr_fd.c \
 			./src/get_next_line_bonus.c ./src/get_next_line_utils_bonus.c \
 			./src/ft_addr.c ./src/ft_hex.c ./src/ft_int.c ./src/ft_print_chr.c \
-			./src/ft_printf.c ./src/ft_strcmp.c ./src/ft_atof.c
+			./src/ft_printf.c ./src/ft_strcmp.c
 			
 			
 OBJS	= $(SRCS:.c=.o)
diff --git a/Libft/utils/src/ft_atof.c b/Libft/utils/src/ft_atof.c
deleted file mode 100644
index 8943ac8..0000000
--- a/Libft/utils/src/ft_atof.c
+++ /dev/null
@@ -1,40 +0,0 @@
-#include <libft.h>
-
-double ft_atof(char *str)
-{
-
-    double result = 0.0;
-    double sign = 1.0;
-    double factor = 0.1;
-
-    // Skip leading white spaces
-    while (*str == ' ') {
-        str++;
-    }
-
-    // Check for sign
-    if (*str == '-') {
-        sign = -1.0;
-        str++;
-    } else if (*str == '+') {
-        str++;
-    }
-
-    // Convert integer part
-    while (*str >= '0' && *str <= '9') {
-        result = result * 10.0 + (*str - '0');
-        str++;
-    }
-
-    // Convert fractional part
-    if (*str == '.') {
-        str++;
-        while (*str >= '0' && *str <= '9') {
-            result += factor * (*str - '0');
-            factor /= 10.0;
-            str++;
-        }
-    }
-
-    return sign * result;
-}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 083fe2c..886d046 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,5 @@
 # CC			= 	cc -fsanitize=leak -g
-CC			= 	cc  -g -O3 -O1 -O2 -fsanitize=address
+CC			= 	cc -o3 -g #-fsanitize=address
 CFLAGS		=  	#-Wall -Wextra -Werror 
 RM			= 	/bin/rm -f
 NAME		= 	a
@@ -129,6 +129,4 @@ upload: $(msg)
 	git commit -m "$$msg"; \
 	git push --force;
 
-
-
 re: fclean all
\ No newline at end of file
diff --git a/include/center.h b/include/center.h
index 30074fa..2538886 100644
--- a/include/center.h
+++ b/include/center.h
@@ -1,13 +1,12 @@
 #include <fcntl.h>
-#include <libft.h>
-#include <math.h>
 #include <mlx.h>
+#include <math.h>
 #include <stdbool.h>
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
 #include <time.h>
-#include <unistd.h>
+
 
 #define SPHERE 1
 #define PLANE 2
@@ -16,263 +15,226 @@
 #define AMBIENT 5
 #define DIRECTIONAL 6
 #define CYLINDER 7
-#define PARABOLOID 8
-#define UNKNOWN 9
+#define PYRAMID 8
+
 
-typedef struct Vec3
+
+struct Vec3
 {
-	double			x;
-	double			y;
-	double			z;
-}					Vec3;
+	double x; //coordenadas
+	double y;
+	double z;
+} typedef Vec3;
 
-typedef struct tValues
+struct tValues
 {
-	double			t0;
-	double			t1;
-	Vec3			normal0;
-	Vec3			normal1;
-}					tValues;
+	double t0; //distance a partir do centro.
+	double t1;
+	Vec3 normal0; //normal do ponto de intersecao
+	Vec3 normal1;
+} typedef tValues;
 
-typedef struct Vec4
+struct Vec4
 {
-	float			r;
-	float			g;
-	float			b;
-}					Vec4;
+	float r;
+	float g;
+	float b;
+} typedef Vec4;
 
-typedef struct Ray
+struct Ray
 {
-	Vec3			o;
-	Vec3			d;
-	tValues			val;
-	Vec3			normal;
-	struct Object	*objc;
-	double			ct;
-	Vec3			_hit;
-}					Ray;
-
-typedef struct Object
+	Vec3 o; //origem
+	Vec3 d;	//direcao
+	tValues val; //hit distance
+	Vec3 normal; //calculo para calcular as sombras
+	struct Object *ObjectClosest;
+	double ct;
+	Vec3 HitPoint;
+} typedef Ray;
+
+struct Object
 {
-	struct Object	*next;
-	Vec3			o;
-	Vec3			d;
-	int				color;
-	Vec3			theta;
-	int				type;
-	double			specular;
-	double			reflection;
-	tValues			(*colision)(struct Object	*obj, struct Ray rayData);
-}					Object;
-
-typedef struct Camera
+	struct Object *next;
+	Vec3 o; //origem
+	Vec3 d; //direcao
+	int color;
+	Vec3 theta;
+	int type; //tipo
+	double specular;
+	double reflection;
+	tValues (*colision)(struct Object *obj, struct Ray rayData); //funcao da colisao
+} typedef Object;
+
+struct Camera
 {
-	struct Camera	*next;
-	Vec3			o;
-	Vec3			d;
-	int				color;
-	Vec3			theta;
-	int				type;
-	double			specular;
-	double			reflection;
-	double			diameter;
-	tValues			(*colision)(struct Object	*obj, struct Ray rayData);
-	double			fov;
-	double			aspect;
-	double			depth;
-	double			width;
-	double			height;
-}					Camera;
-
-typedef struct Sphere
+	struct Camera *next;
+	Vec3 o;
+	Vec3 d;
+	Vec3 theta;
+	int type;
+	double fov;
+	double aspectRatio;
+	double width;
+	double height;
+} typedef Camera;
+
+
+struct Sphere
 {
-	struct Object	*next;
-	Vec3			o;
-	Vec3			d;
-	int				color;
-	Vec3			theta;
-	int				type;
-	double			specular;
-	double			reflection;
-	tValues			(*colision)(struct Object	*obj, struct Ray	rayData);
-	double			diameter;
-}					Sphere;
-
-typedef struct Plane
+	struct Object *next;
+	Vec3 o; //origem
+	Vec3 d; //direcao
+	int color;
+	Vec3 theta;
+	int type; //tipo
+	double specular;
+	double reflection;
+	tValues (*colision)(struct Object *obj, struct Ray rayData);
+	double diameter;
+} typedef Sphere;
+
+struct Plane
 {
-	struct Object	*next;
-	Vec3			o;
-	Vec3			d;
-	int				color;
-	Vec3			theta;
-	int				type;
-	double			specular;
-	double			reflection;
-	tValues			(*colision)(struct Object	*obj, struct Ray	rayData);
-	float			size;
-	int				checkerboard;
-}					Plane;
-
-typedef struct Light
+	struct Object *next;
+	Vec3 o; //origem
+	Vec3 d; //direcao
+	int color;
+	Vec3 theta;
+	int type; //tipo
+	double specular;
+	double reflection;
+	tValues (*colision)(struct Object *obj, struct Ray rayData);
+	float size;
+	int checkerboard;
+} typedef Plane;
+
+struct Light
 {
-	struct Object	*next;
-	Vec3			o;
-	Vec3			d;
-	int				color;
-	Vec3			theta;
-	int				type;
-	double			specular;
-	double			r;
-	tValues			(*colision)(struct Object	*obj, struct Ray	rayData);
-	double			i;
-}					Light;
-
-typedef struct Cylinder
+	struct Object *next;
+	Vec3 o; //origem
+	Vec3 d; //direcao
+	int color;
+	Vec3 theta;
+	int type; //tipo
+	double specular;
+	double reflection;
+	tValues (*colision)(struct Object *obj, struct Ray rayData);
+	double intensity;
+} typedef Light;
+
+
+struct Cylinder
 {
-	struct Object	*next;
-	Vec3			o;
-	Vec3			d;
-	int				color;
-	Vec3			theta;
-	int				type;
-	double			specular;
-	double			reflection;
-	tValues			(*colision)(struct Object	*obj, struct Ray	rayData);
-	double			diameter;
-	double			height;
-}					Cylinder;
-
-typedef struct Paraboloid
+    struct Object *next;
+	Vec3 o; //origem
+	Vec3 d; //direcao
+	int color;
+	Vec3 theta;
+	int type; //tipo
+	double specular;
+	double reflection;
+	tValues (*colision)(struct Object *obj, struct Ray rayData);
+    double diameter;
+    double height;
+} typedef Cylinder;
+
+struct Pyramid
 {
-	struct Object	*next;
-	Vec3			o;
-	Vec3			d;
-	int				color;
-	Vec3			theta;
-	int				type;
-	double			specular;
-	double			reflection;
-	tValues			(*colision)(struct Object	*obj, struct	Ray rayData);
-	double			diameter;
-
-	double			p;
-	double			height;
-}					Paraboloid;
+	struct Object *next;
+	Vec3 o; //origem
+	Vec3 d; //direcao
+	int color;
+	Vec3 theta;
+	int type; //tipo
+	double specular;
+	double reflection;
+	tValues (*colision)(struct Object *obj, struct Ray rayData);
+	double height;
+	double width;
+	Vec3 vertices[11]; // Array de vértices que formam a pirâmide
+    Vec3 normals[10];  // Array de normais para cada face da pirâmide
+} typedef Pyramid;
 
 typedef struct s_mlxdata
 {
-	void			*mlx;
-	void			*win;
-	void			*img;
-	char			*addr;
-	int				bits_per_pixel;
-	int				line_length;
-	int				endian;
-}					t_mlxdata;
-
-typedef struct scene
+	void				*mlx;
+	void				*win;
+	void				*img;
+	char				*addr;
+	int					bits_per_pixel;
+	int					line_length;
+	int					endian;
+}						t_mlxdata;
+
+
+
+
+
+
+struct scene
 {
-	Camera			*camera;
-	Object			*objects;
-	Light			*lights;
-	Light			*am;
-	t_mlxdata		*mlx;
-	int				width;
-	int				height;
-	int				depth;
-	int				error;
-}					gscene;
-
-extern gscene		*g_scene;
-
-// Mathmatical Functions
-Vec3				norm(Vec3 v);
-Vec3				add(Vec3 a, Vec3 b);
-Vec3				sub(Vec3 a, Vec3 b);
-Vec3				mul(Vec3 a, double b);
-Vec3				divv(Vec3 a, double b);
-Vec3				unitvector(Vec3 v);
-Vec3				cross(Vec3 a, Vec3 b);
-Vec4				add4(Vec4 a, Vec4 b);
-Vec4				mul4(Vec4 a, double b);
-double				dot(Vec3 a, Vec3 b);
-double				len(Vec3 v);
-double				maxval(double a, double b);
-double				minval(double a, double b);
-double				randomlimited(double min, double max);
-Vec3				randomDirection(void);
-Vec3				normalcalc(Object *obj, Vec3 p);
-Vec3				rotate(Vec3 point, Vec3 axis, double angle);
-
-// Initialize Functions
-gscene				*init_main(int width, int height, int depth);
-bool				initialize_mlx(gscene *s);
-
-// Mlx Functions
-void				my_mlx_pixel_put(double x, double y, int rgb);
-double				tocanvas(double x, bool isHeight);
-
-// Color Functions
-int					newrgb(int r, int g, int b);
-double				mulcomp(int color, int shifting, double intensity);
-int					colmul(int color, double intensity);
-
-// Object Functions
-Sphere				*newSphere(int type, char **props);
-Plane				*newPlane(int type, char **props);
-Light				*newlight(int type, char **props);
-Cylinder			*newCylinder(int type, char **props);
-Camera				*newCamera(int type, char **props);
-Paraboloid			*newParaboloid(int type, char **props);
-
-tValues				quadraticsolver(double a, double b, double c);
-tValues				spherecolision(struct Object *s, Ray raydata);
-tValues				planecolision(Plane *plane, Ray ray);
-tValues				planecolisioncylinder(Vec3 planep, Vec3 planen, Ray ray,
-						double radius);
-tValues				calculatetvalues(Vec3 oc, Ray ray, Cylinder *cylinder);
-tValues				calculatetopplanecolision(Ray ray, Cylinder *cylinder);
-tValues				calculatebotplanecolision(Ray ray, Cylinder *cylinder);
-tValues				calculateplanecolisions(Ray ray, Cylinder *cylinder);
-Vec3				calculatenormalone(tValues t, Vec3 p1, Cylinder *cylinder);
-Vec3				calculatenormaltwo(tValues t, Vec3 p2, Cylinder *cylinder);
-tValues				calculatenormals(tValues t, Vec3 p1, Vec3 p2,
-						Cylinder *cylinder);
-tValues				paraboloidCollision(Paraboloid *paraboloid, Ray ray);
-void				checkheight(tValues *t, Vec3 p1, Vec3 p2,
-						Cylinder *cylinder);
-tValues				cylindercolision(Cylinder *cylinder, Ray ray);
-void				objectadd(Object *nObj, void **list);
-
-// Ray Functions
-Ray					getraydir(Vec3 o, double x, double y);
-
-// Reflection Functions
-Vec3				reflect(Vec3 incident, Vec3 normal);
-double				refl(Vec3 data, Vec3 reflected, Vec3 vect);
-double				to_reflect(Vec3 light, Vec3 n, Vec3 vect, Vec3 *reflected);
-void				calc_combined(Vec4 *combined, int light_color,
-						double brightness);
-
-// lighting Functions
-void				diffusion(Vec4 *combined, Vec3 normal, Vec3 light,
-						Light *src);
-int					shadow(Vec3 origin, Vec3 dir, double t_min, double t_max);
-
-Vec4				limit(Vec4 v);
-int					skip(Light **l);
-Object				*intersections(Ray *rt, double md, double d, bool set);
-Vec4				calcligh(Vec3 p, Vec3 n, Vec3 v, double spec);
-
-bool				parse(char *f);
-bool				float_requirements(char *s, int start, int end);
-bool				vector_requirements(char *s);
-double				getfloat(char *prop, bool required, float *range,
-						int standard_value);
-Vec3				getVec4(char *prop, bool required, float max, float min);
-void				updateError(char *msg);
-void				printprops(char **line, char *name, const char *funcname);
-void				delprops(char **line);
-void				del(Object **lsg);
-bool				distributeobject(int type, char **props);
-bool				generateobject(char **props);
\ No newline at end of file
+	Camera *camera;
+	Object *objects;
+	Light *lights;
+
+	// Mlx information.
+	t_mlxdata *mlx;
+
+	// Image information.
+	int width;
+	int height;
+
+} typedef gscene;
+
+
+//Initialize Functions
+gscene *init_MainStruct(int width, int height);
+
+
+extern gscene *scene;
+
+double Dot(Vec3 a, Vec3 b);
+double Length(Vec3 v);
+Vec3 Normalize(Vec3 v);
+Vec3 Add(Vec3 a, Vec3 b);
+Vec3 Sub(Vec3 a, Vec3 b);
+Vec3 Mul(Vec3 a, double b);
+Vec3 Div(Vec3 a, double b);
+Vec3 unitVector(Vec3 v);
+Vec3 Cross(Vec3 a, Vec3 b);
+Vec4 Add4(Vec4 a, Vec4 b);
+Vec4 Mul4(Vec4 a, double b);
+Vec4 create_color(unsigned int t, unsigned int r, unsigned int g, unsigned int b);
+int rgbGetter(int r, int g, int b);
+double plusComponent(int color, int shifting, double intensity);
+int colorMultiply(int color, double intensity);
+
+Vec4 create_color(unsigned int t, unsigned int r, unsigned int g, unsigned int b);
+void	my_mlx_pixel_put(double x, double y, int rgb);
+
+
+
+Object *newObject(size_t ModelType, Vec3 o, Vec3 d, Vec4 color, Vec3 theta);
+Sphere *newSphere(Vec3 o, Vec3 d, Vec4 color, Vec3 theta, double diameter, tValues (*colision)(), double reflec, double specular);
+Plane *newPlane(Vec3 o, Vec3 d, Vec4 color, Vec3 theta, float size, tValues (*colision)(), double reflec, double specular, int checkerboard);
+Camera *newCamera(Vec3 o, Vec3 d, double fov, Vec3 theta);
+Cylinder *newCylinder(Vec3 o, Vec3 d, double diameter, double height, Vec4 color, Vec3 theta, tValues (*colision)(), double reflec, double specular);
+Light *newLight(Vec3 o, Vec3 d, Vec4 color, Vec3 theta, double intensity, int type);
+
+double toCanvas(double x, bool isHeight);
+Ray GetRayDir(Vec3 o, double x, double y);
+tValues sphereColision(Sphere *s, Ray rayData);
+tValues planeColision(Plane *plane, Ray ray);
+tValues planeColisionCylinder(Vec3 planePoint, Vec3 planeNormal, Ray ray, double radius);
+tValues cylinderColision(Cylinder *cylinder, Ray ray);
+tValues pyramidCollision(Pyramid *pyramid, Ray ray);
+double Max(double a, double b);
+double Min(double a, double b);
+double degrees_to_radians(double degrees);
+double random_double();
+double randomLimited(double min, double max);
+void objectAdd(Object *nObj, Object **lst);
+Vec3 randomDirection();
+Vec3 rotate(Vec3 point, Vec3 axis, double angle);
+
+Vec3 Reflect(Vec3 incident, Vec3 normal);
\ No newline at end of file
diff --git a/mini.rt b/mini.rt
deleted file mode 100644
index be22648..0000000
--- a/mini.rt
+++ /dev/null
@@ -1,28 +0,0 @@
-# HOW TO USE IT : ./miniRT mini.rt
-# MODEL TYPE - MANDATORY PARTS - BONSUS PARTS {SPECULAR - REFLECTION}
-# TO COMMENT A LINE USE # AT THE BEGINNING OF THE LINE DOES NOT WORK IN THE MIDDLE
-
-sp 0,0,0 1 255,0,0
-
-L 4,4,-4 0.3 255,255,255
-L -4,4,-4 0.3 255,255,255
-L 4,4,4 0.3 255,255,255
-L -4,4,4 0.3 255,255,255
-
-
-pl 0,5,0    0,1,0       255,255,255			1 1 0
-pl 0,-5,0   0,1,0       255,255,255			1 1 0
-pl 5,0,0    1,0,0       255,255,255			1 1 0
-pl -5,0,0   1,0,0       255,255,255			1 1 0
-pl 0,0,5    0,0,1       255,255,255			1 1 0
-pl 0,0,-5    0,0,1       255,255,255	    1 1 0
-
-A 0.0 255,255,255
-C 0,0,-10 1,1,1 90
-# L 0,2.5,0 1 255,255,255
-
-
-
-
-
-
diff --git a/src/.utils.1.c b/src/.utils.1.c
index 4a20c31..95bbff5 100644
--- a/src/.utils.1.c
+++ b/src/.utils.1.c
@@ -1,141 +1,78 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   .utils.1.c                                         :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 00:36:02 by psoares-          #+#    #+#             */
-/*   Updated: 2024/02/12 18:57:04 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
 #include "center.h"
 
-
-void	rotation_x(Vec3 *vec, Vec3 *theta)
-{
-    double	temp_z;
-    double	temp_y;
-
-    temp_z = vec->z;
-    temp_y = vec->y;
-    vec->y = temp_y * cos(theta->x) + temp_z * sin(theta->x);
-    vec->z = -temp_y * sin(theta->x) + temp_z * cos(theta->x);
-}
-
-void	rotation_y(Vec3 *vec, Vec3 *theta)
+Vec4 getBackgroundColor(Ray raytrace)
 {
-    double	temp_x;
-    double	temp_z;
-
-    temp_x = vec->x;
-    temp_z = vec->z;
-    vec->x = temp_x * cos(theta->y) + temp_z * sin(theta->y);
-    vec->z = -temp_x * sin(theta->y) + temp_z * cos(theta->y);
+    Vec4 color = (Vec4){0, 0, 0, 0};
+    Vec3 unit_direction = unitVector(raytrace.d);
+    double t = 0.5 * (unit_direction.y + 1.0);
+    unsigned int white = 0xFFFFFF; // RGB white
+    unsigned int blue = 0x7FB2FF;  // RGB blue
+    color.r = (unsigned int)((1.0 - t) * ((white >> 16) & 0xFF) + t * ((blue >> 16) & 0xFF));
+    color.g = (unsigned int)((1.0 - t) * ((white >> 8) & 0xFF) + t * ((blue >> 8) & 0xFF));
+    color.b = (unsigned int)((1.0 - t) * (white & 0xFF) + t * (blue & 0xFF));
+    return color;
 }
 
-void	rotation_z(Vec3 *vec, Vec3 *theta)
-{
-    double	temp_x;
-    double	temp_y;
+Ray GetRayDir(Vec3 o, double x, double y){
 
-    temp_x = vec->x;
-    temp_y = vec->y;
-    vec->x = temp_x * cos(theta->z) - temp_y * sin(theta->z);
-    vec->y = temp_x * sin(theta->z) + temp_y * cos(theta->z);
-}
-
-void rotatee(Vec3 *v, Vec3 *theta) {
-    rotation_x(v, theta);
-    rotation_y(v, theta);
-    rotation_z(v, theta);
-}
-
-Ray	getraydir(Vec3 o, double x, double y)
-{
-	Camera	*cam;
-	Ray		ray;
-
-	cam = g_scene->camera;
+	Camera *cam = scene->camera;
+	Ray ray;
 	ray.o = o;
-	ray.d.x = ((x) / g_scene->width) * cam->width;
-	ray.d.y = ((y) / g_scene->height) * cam->height;
+	ray.d.x = x / scene->width * cam->width;
+	ray.d.y = y / scene->height * cam->height * scene->camera->aspectRatio;
 	ray.d.z = 1;
-	ray.o = cam->o;
-	ray.val = (tValues){.t0 = INFINITY, .t1 = INFINITY};
-	ray.objc = NULL;
-	return (ray);
+    ray.o = cam->o;
+    ray.val = (tValues){INFINITY, INFINITY};
+	ray.ObjectClosest = NULL;
+	return ray;
 }
 
-
-void lights(Light *l, Light **lst)
+void objectAdd(Object *nObj, Object **lst)
 {
-    Light *head;
-
-    head = *lst;
-    if(!*lst) {
-        *lst = l;
+    if (!*lst)
+    {
+        *lst = nObj;
         return;
     }
-    while(*lst && (*lst)->next)
-        (*lst) = (Object *)(*lst)->next;
-    (*lst)->next = l;
-    *lst = head;
+    Object *tmp = *lst;
+    while (tmp->next)
+        tmp = tmp->next;
+    tmp->next = nObj;
 }
 
-void	objects(Object *l, Object **lst)
+Vec3 normalCalc(Object *obj, Vec3 p)
 {
-	Object	*head;
-
-	head = *lst;
-	if (!*lst)
-	{
-		*lst = l;
-		return ;
-	}
-	while ((*lst)->next)
-		(*lst) = (*lst)->next;
-	(*lst)->next = l;
-	*lst = head;
-}
-
-void	camera(Camera *l, Camera **lst)
-{
-	Camera	*head;
-
-	head = *lst;
-	if (!*lst)
-	{
-		*lst = l;
-		return ;
-	}
-	while ((*lst)->next)
-		(*lst) = (Camera *)(*lst)->next;
-	(*lst)->next = l;
-	*lst = head;
-}
+    Vec3 normal;
+    normal = (Vec3){0, 0, 0};
+    if (!obj)
+        return normal;
+    if (obj->type == SPHERE)
+    {
+        normal = Sub(p, (obj)->o);
+        normal = Normalize(normal);
+    }
+    else if (obj->type == PLANE)
+        normal = ((Plane *)obj)->d;
+    else if (obj->type == CYLINDER)
+    {
+        Cylinder *c = (Cylinder *)obj;
+        Vec3 oc = Sub(p, c->o);
+        double t = Dot(oc, c->d);
+        if (fabs(t) < 0.001 || fabs(t - c->height) < 0.001)
+            normal = c->d; // Cap normal
+        else
+        {
+            normal = Sub(oc, Mul(c->d, t));
+            normal = Normalize(normal);
+        }
+        
+    }
+    else if (obj->type == PYRAMID)
+    {
+        Pyramid *pyr = (Pyramid *)obj;
+        normal = Sub(p, pyr->d);
+        normal = Normalize(normal);
+    }
 
-void	objectadd(Object *nObj, void **list)
-{
-	if (!nObj)
-		return ;
-	if (nObj->type == POINT || nObj->type == AMBIENT)
-		lights((Light *)nObj, (Light **)list);
-	else if (nObj->type == CAMERA)
-		camera((Camera *)nObj, (Camera **)list);
-	else if (nObj->type == SPHERE || nObj->type == PLANE || \
-	nObj->type == CYLINDER || nObj->type == PARABOLOID)
-		objects(nObj, (Object **)list);
+    return normal;
 }
-
-
-void	del(Object **lsg)
-{
-	if (!lsg)
-		return ;
-	if (!*lsg)
-		return ;
-	del(&(*lsg)->next);
-	free(*lsg);
-}
\ No newline at end of file
diff --git a/src/GetFunctions/Float.c b/src/GetFunctions/Float.c
deleted file mode 100644
index c206f1b..0000000
--- a/src/GetFunctions/Float.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   Float.c                                            :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/10 22:39:06 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/12 20:32:02 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-static int	setdata(bool *ptr, bool data, int res)
-{
-	if (*ptr == data)
-		return (2);
-	*ptr = data;
-	return (res);
-}
-
-static bool	custom_char(char c)
-{
-	return ((!ft_isdigit(c) && c != '.' && c != '-' && \
-	c != '+'));
-}
-
-bool	float_requirements(char *s, int start, int end)
-{
-	bool	asdot;
-	bool	assignal;
-
-	asdot = false;
-	assignal = false;
-	if (start > end)
-		return (false);
-	while (start < end && s[start] && s[start] != '\n' )
-	{
-		if (s[start] == ',')
-			if (start == 0 || s[start - 1] == ',' || s[start + 1] == ',')
-				return (true);
-		if (s[start] == '-' || s[start] == '+')
-		{
-			if ((start != 0 && s[start - 1] != ',') || assignal)
-				return (true);
-			assignal = true;
-		}
-		if (s[start] == '.' && setdata(&asdot, true, 0) == 2)
-			return (true);
-		if (custom_char(s[start]))
-			return (true);
-		start++;
-	}
-	return (false);
-}
-
-double	newfloat(char *s, float max, float min)
-{
-	double	f;
-
-	if (float_requirements(s, 0, (int)ft_strlen(s)))
-		return (updateError("Error: Invalid float value") ,0);
-	f = ft_atof(s);
-	if (f > max || f < min)
-		return (updateError("Error: Invalid float range"), 0);
-	return (f);
-}
-
-double	getfloat(char *prop, bool required, float *range, int standard_value)
-{
-	if (required)
-	{
-		if (!prop)
-		{
-			updateError("Field required\n");
-			return (standard_value);
-		}
-		return (newfloat(prop, range[0], range[1]));
-	}
-	return (standard_value);
-}
diff --git a/src/GetFunctions/Vec3.c b/src/GetFunctions/Vec3.c
deleted file mode 100644
index 4e706da..0000000
--- a/src/GetFunctions/Vec3.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   Vec3.c                                             :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/10 22:41:07 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/12 20:28:51 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-bool	float_requirements(char *s, int start, int end);
-
-bool	vector_requirements(char *s)
-{
-	char	**props;
-	int		prop;
-	int		i;
-	int		commas;
-
-	commas = 0;
-	prop = -1;
-	while (s[++i])
-		if (s[i] == ',')
-			commas++;
-	if (commas != 2)
-		return (true);
-	props = ft_split(s, ',');
-	if (!props)
-		return (true);
-	while (props[++prop])
-		if (float_requirements(props[prop], 0, ft_strlen(props[prop])))
-		{
-			printf("Error: Invalid Vec3 value\n");
-			return (delprops(props), true);
-		}
-	delprops(props);
-	if (prop != 3)
-		return (true);
-	return (false);
-}
-
-static Vec3	newvec4(char *s, float max, float min)
-{
-	Vec3	v;
-	char	**split;
-
-	printf("%sNew Vec: %s%s\n", HBLU, s, RESET);
-	if (vector_requirements(s))
-	{
-		updateError("Error: Invalid Vec3 value");
-		return ((Vec3){0, 0, 0});
-	}
-	split = ft_split(s, ',');
-	v.x = ft_atof(split[0]);
-	v.y = ft_atof(split[1]);
-	v.z = ft_atof(split[2]);
-	if (v.x > max || v.x < min || v.y > max || v.y < min || v.z > max ||
-		v.z < min)
-		updateError("Error: Invalid Vec out of range");
-	delprops(split);
-	return (v);
-}
-
-Vec3	getVec4(char *prop, bool required, float max, float min)
-{
-	if (required && !prop)
-	{
-		if (!g_scene)
-			updateError("Expected Vec3\n");
-		return ((Vec3){0, 0, 0});
-	}
-	if (g_scene->error)
-		return ((Vec3){0, 0, 0});
-	return (newvec4(prop, max, min));
-}
diff --git a/src/GetFunctions/utils.c b/src/GetFunctions/utils.c
deleted file mode 100644
index 43cb815..0000000
--- a/src/GetFunctions/utils.c
+++ /dev/null
@@ -1,30 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   utils.c                                            :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/12 17:10:13 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/12 17:10:17 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-
-void	updateError(char *msg)
-{
-	if(write(2, RED, ft_strlen(RED)) == -1)
-		NULL;
-	if(write(2, "Error: ", 7) == -1)
-		NULL;
-	if(write(2, RESET, ft_strlen(RESET)) == -1)
-		NULL;
-	if(write(2, msg, ft_strlen(msg)) == -1)
-		NULL;
-	if(write(2, "\n", 1) == -1)
-		NULL;
-	g_scene->error = 1;
-}
-
diff --git a/src/Initializers/utils.1.c b/src/Initializers/utils.1.c
index 7633a08..e3b6ca0 100644
--- a/src/Initializers/utils.1.c
+++ b/src/Initializers/utils.1.c
@@ -1,56 +1,50 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   utils.1.c                                          :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/05 21:32:45 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/12 16:49:55 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
 #include <center.h>
 
-static void	*err(gscene **s)
+static void *err(gscene **main)
 {
-	free(*s);
-	return (NULL);
+    if(!*main)
+        return NULL;
+    free(*main);
+    *main = NULL;
+    return (void *)*main;
 }
 
-bool	initialize_mlx(gscene *s)
-{
-	s->mlx = ft_calloc(sizeof(t_mlxdata), 1);
-	s->mlx->mlx = mlx_init();
-	if (!s->mlx->mlx)
-		return (false);
-	s->mlx->win = mlx_new_window(s->mlx->mlx, s->width, s->height, "miniRT");
-	if (!s->mlx->win)
-		return (false);
-	s->mlx->img = mlx_new_image(s->mlx->mlx, s->width, s->height);
-	if (!s->mlx->img)
-		return (false);
-	s->mlx->addr = mlx_get_data_addr(s->mlx->img, &s->mlx->bits_per_pixel, \
-		&s->mlx->line_length, &s->mlx->endian);
-	if (!s->mlx->addr)
-		return (false);
-	return (true);
+bool	initialize_mlx(gscene *s){
+    s->mlx->mlx = mlx_init();
+    if(!s->mlx->mlx)
+        return (false);
+    s->mlx->win = mlx_new_window(s->mlx->mlx, s->width,s->height, "miniRT");
+    if(!s->mlx->win)
+        return (false);
+    s->mlx->img = mlx_new_image(s->mlx->mlx, s->width,s->height);
+    if(!s->mlx->img)
+        return (false);
+    s->mlx->addr = mlx_get_data_addr(s->mlx->img, &s->mlx->bits_per_pixel,
+                                         &s->mlx->line_length, &s->mlx->endian);
+    if(!s->mlx->addr)
+        return (false);
+    return (true);
 }
 
-gscene	*init_main(int width, int height, int depth)
+gscene *init_MainStruct(int width, int height)
 {
-	gscene	*m;
+    gscene *m;
 
-	m = malloc(sizeof(gscene));
-	if (!m)
-		return (NULL);
-	m->depth = depth;
-	m->width = width;
-	m->height = height;
-	m->camera = NULL;
-	m->objects = NULL;
-	m->lights = NULL;
-	m->am = NULL;
-	m->error = 0;
-	return (m);
+    m = NULL;
+    printf("Sizeof %lu\n\n\n", sizeof(gscene));
+    m = malloc(sizeof(gscene));
+    if(!m)
+        return NULL;
+    m->width = width;
+    m->height = height;
+    m->camera = NULL;
+    m->objects = NULL;
+    m->lights = NULL;
+    m->mlx = malloc(sizeof(t_mlxdata));
+    if (!m->mlx)
+        return (gscene *)err(&m);
+    if(!initialize_mlx(m))
+        return (gscene *)err(&m);
+    return m;
 }
+
diff --git a/src/MathFunctions/utils.1.c b/src/MathFunctions/utils.1.c
index e7bbd78..f06b3b2 100644
--- a/src/MathFunctions/utils.1.c
+++ b/src/MathFunctions/utils.1.c
@@ -1,43 +1,47 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   utils.1.c                                          :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/05 21:39:02 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/08 11:39:02 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
 #include <center.h>
 
-double	clamp(double n, double min, double max)
+double degrees_to_radians(double degrees)
 {
-	if (n < min)
-		return (min);
-	if (n > max)
-		return (max);
-	return (n);
+    return degrees * M_PI / 180.0;
 }
 
-double	maxval(double a, double b)
+double random_double()
 {
-	if (a > b)
-		return (a);
-	return (b);
+    // Returns a random real in [0,1).
+    return rand() / (RAND_MAX + 1.0);
 }
 
-double	minval(double a, double b)
+double randomLimited(double min, double max)
 {
-	if (a < b)
-		return (a);
-	return (b);
+    // Returns a random real in [min,max).
+    return min + (max-min)*random_double();
+}
+
+double Clamp(double n, double min, double max){
+    if (n < min)
+        return min;
+    if (n > max)
+        return max;
+    return n;
 }
 
-double	tocanvas(double x, bool isheight)
+double Max(double a, double b)
 {
-	if (isheight)
-		return ((double)g_scene->height / 2 - x);
-	return (x + (double)g_scene->width / 2);
+    if (a > b)
+        return a;
+    return b;
 }
+
+double Min(double a, double b)
+{
+    if (a < b)
+        return a;
+    return b;
+}
+
+double toCanvas(double x, bool isHeight){
+    if(isHeight)
+        return (double)scene->height / 2 - x;
+    return x + (double)scene->width / 2;
+}
+
diff --git a/src/Objects/Colisions.c b/src/Objects/Colisions.c
index 72a2ed7..b6acecd 100644
--- a/src/Objects/Colisions.c
+++ b/src/Objects/Colisions.c
@@ -1,99 +1,218 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   Colisions.c                                        :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 01:06:59 by psoares-          #+#    #+#             */
-/*   Updated: 2024/02/12 20:03:27 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
 #include <center.h>
 
-tValues	spherecolision(struct Object *s, Ray raydata)
+tValues sphereColision(Sphere *s, Ray rayData)
 {
-	tValues	t;
-	Vec3	oc;
-	Sphere	*sphere;
-
-	sphere = (Sphere *)s;
-	oc = sub(raydata.o, sphere->o);
-	t = quadraticsolver(dot(raydata.d, raydata.d), 2 * dot(oc, raydata.d), \
-	dot(oc, oc) - (sphere->diameter));
-	return (t);
+    tValues t;
+    Vec3 oc = Sub(rayData.o, s->o);
+    double a = Dot(rayData.d, rayData.d);
+    double b = 2 * Dot(oc, rayData.d);
+    double c = Dot(oc, oc) - (s->diameter);
+    double discriminant = b * b - 4 * a * c;
+    if(discriminant < 0)
+    {
+        t.t0 = INFINITY;
+        t.t1 = INFINITY;
+        return t;
+    }
+    t.t0 = (-b - sqrt(discriminant)) / (2 * a);
+    t.t1 = (-b + sqrt(discriminant)) / (2 * a);
+    return t;
 }
 
-tValues	planecolision(Plane *plane, Ray ray)
+tValues planeColision(Plane *plane, Ray ray)
 {
-	double	numerator;
-	tValues	t;
-
-	numerator = 0;
-	numerator = plane->d.x * (ray.o.x - plane->o.x);
-	numerator += plane->d.y * (ray.o.y - plane->o.y);
-	numerator += plane->d.z * (ray.o.z - plane->o.z);
-	numerator *= -1;
-	t.t0 = numerator / (plane->d.x * \
-		ray.d.x + plane->d.y * \
-		ray.d.y + plane->d.z * \
-		ray.d.z);
-	t.t1 = 0;
-	return (t);
-}
+    double numerator = 0;
+    tValues t;
 
-double vcos(Vec3 a, Vec3 b) {
-	return dot(a, b) / (len(a) * len(b));
+    numerator = 0;
+    numerator = plane->d.x * (ray.o.x - plane->o.x);
+    numerator += plane->d.y * (ray.o.y - plane->o.y);
+    numerator += plane->d.z * (ray.o.z - plane->o.z);
+
+    numerator *= -1;
+    t.t0 = numerator / (plane->d.x * ray.d.x + plane->d.y * ray.d.y + plane->d.z * ray.d.z);
+    t.t1 = 0;
+    return t;
 }
 
-int p_is_outside(Vec3 p1, Vec3 p2, Vec3 p3, Vec3 ip) {
-	Vec3 v1 = sub(p2, p1);
-	Vec3 v2 = sub(p3, p1);
-	Vec3 vp = sub(ip, p1);
-	if (vcos(cross(v1, v2), cross(v1, vp)) < 0)
-		return 1;
-	return 0;
+tValues planeColisionCylinder(Vec3 planePoint, Vec3 planeNormal, Ray ray, double radius) 
+{
+    tValues t;
+    double denominador = Dot(ray.d, planeNormal);
+
+    // Se o raio é paralelo ao plano, não há interseção
+    if (fabs(denominador) < 0.001)
+    {
+        t.t0 = INFINITY;
+        t.t1 = INFINITY;
+        return t;
+    }
+
+    double numerator = Dot(Sub(planePoint, ray.o), planeNormal);
+    t.t0 = numerator / denominador;
+    t.t1 = INFINITY; // Um plano tem apenas um ponto de interseção
+    Vec3 intersectionPoint = Add(ray.o, Mul(ray.d, t.t0));
+
+    // Verifique se o ponto de interseção está dentro do raio do disco
+    double distance = Length(Sub(intersectionPoint, planePoint));
+    if (distance > radius)
+        t.t0 = INFINITY;
+    return t;
 }
 
-bool isWithinTopDisk(Paraboloid *paraboloid, Vec3 intersection) {
-    double rMax = paraboloid->diameter / 2; // Define your maximum radius
+tValues cylinderColision(Cylinder *cylinder, Ray ray)
+{
+    tValues t;
+    Vec3 oc = Sub(ray.o, cylinder->o);
+    double a = Dot(ray.d, ray.d) - Dot(ray.d, cylinder->d) * Dot(ray.d, cylinder->d);
+    double b = 2 * (Dot(ray.d, oc) - Dot(ray.d, cylinder->d) * Dot(oc, cylinder->d));
+    double radius = cylinder->diameter / 2;
+    double c = Dot(oc, oc) - Dot(oc, cylinder->d) * Dot(oc, cylinder->d) - radius * radius;
+    double discriminant = b * b - 4 * a * c;
+    if(discriminant < 0)
+    {
+        t.t0 = INFINITY;
+        t.t1 = INFINITY;
+    }
+    else
+    {
+        t.t0 = (-b - sqrt(discriminant)) / (2 * a);
+        t.t1 = (-b + sqrt(discriminant)) / (2 * a);
+    }
+    Vec3 P1 = Add(ray.o, Mul(ray.d, t.t0));
+    Vec3 P2 = Add(ray.o, Mul(ray.d, t.t1));
+
+    double h1 = Dot(Sub(P1, cylinder->o), cylinder->d);
+    double h2 = Dot(Sub(P2, cylinder->o), cylinder->d);
+
+    if(h1 < 0 || h1 > cylinder->height)
+        t.t0 = INFINITY;
+    if (h2 < 0 || h2 > cylinder->height)
+        t.t1 = INFINITY;
+
+    Vec3 topCenter = Add(cylinder->o, Mul(cylinder->d, cylinder->height));
+    Vec3 botCenter = cylinder->o;
+    tValues top = planeColisionCylinder(topCenter, cylinder->d, ray, cylinder->diameter / 2);
+    tValues bot = planeColisionCylinder(botCenter, cylinder->d, ray, cylinder->diameter / 2);
+
+    Vec3 Ptop = Add(ray.o, Mul(ray.d, top.t0));
+    Vec3 Pbot = Add(ray.o, Mul(ray.d, bot.t0));
+
+    if (Length(Sub(Ptop, topCenter)) > radius)
+        top.t0 = INFINITY;
+    if (Length(Sub(Pbot, botCenter)) > radius)
+        bot.t0 = INFINITY;
+
+    if(t.t0 == INFINITY && t.t1 == INFINITY && top.t0 == INFINITY && bot.t0 == INFINITY)
+    {
+        return t;
+    }
+    else
+    {
+         tValues result;
+        result.t0 = Min(t.t0, Min(top.t0, bot.t0));
+        result.t1 = t.t1;
+        // Calculate normals
+        Vec3 normal0 = Sub(P1, cylinder->o);
+        double dot0 = Dot(normal0, cylinder->d);
+        result.normal0 = Normalize(Sub(normal0, Mul(cylinder->d, dot0)));
+
+        Vec3 normal1 = Sub(P2, cylinder->o);
+        double dot1 = Dot(normal1, cylinder->d);
+        result.normal1 = Normalize(Sub(normal1, Mul(cylinder->d, dot1)));
+
+        return result;
+    }
+}
 
-    // Calculate the distance from the intersection to the center of the disk in the xy plane
-    double dx = intersection.x - paraboloid->o.x;
-    double dy = intersection.y - paraboloid->o.y;
-    double distance = sqrt(dx*dx + dy*dy);
+#include <math.h>
 
-    // Check if the intersection is within the top disk
-    return intersection.z >= paraboloid->height && distance <= rMax;
+double solve_plane(Vec3 o, Vec3 d, Vec3 p, Vec3 normal) {
+    double denom = Dot(d, normal);
+    if (fabs(denom) > 1e-6) {
+        Vec3 p0l0 = Sub(p, o);
+        double t = Dot(p0l0, normal) / denom;
+        return t;
+    }
+    return INFINITY;
 }
 
-bool isWithinBounds(Paraboloid *paraboloid, Vec3 intersection) {
-    double zMin = 10; // Define your zMin
-    double zMax = 10000; // Define your zMax
-    return intersection.z >= zMin && intersection.z <= zMax;
+double vcos(Vec3 a, Vec3 b) {
+    return Dot(a, b) / (Length(a) * Length(b));
 }
 
-tValues paraboloidCollision(Paraboloid *paraboloid, Ray ray) 
-{
-	printf("Paraboloid\n");
-    tValues t;
-    Vec3 oc = sub(ray.o, paraboloid->o);
-    double a =  pow(ray.d.x, 2) / pow(paraboloid->diameter, 2) + pow(ray.d.y, 2) / pow(paraboloid->height, 2);
-    double b = 2 * (ray.d.x * oc.x / pow(paraboloid->diameter, 2) + ray.d.y * oc.y / pow(paraboloid->height, 2) - ray.d.z);
-    double c = pow(oc.x, 2) / pow(paraboloid->diameter, 2) + pow(oc.y, 2) / pow(paraboloid->height, 2) - oc.z;
-    t = quadraticsolver(a, b, c);
+int p_is_outside(Vec3 p1, Vec3 p2, Vec3 p3, Vec3 ip) {
+    Vec3 v1 = Sub(p2, p1);
+    Vec3 v2 = Sub(p3, p1);
+    Vec3 vp = Sub(ip, p1);
+    if (vcos(Cross(v1, v2), Cross(v1, vp)) < 0)
+        return 1;
+    return 0;
+}
 
-    Vec3 intersection1 = add(ray.o, mul(ray.d, t.t0));
-    Vec3 intersection2 = add(ray.o, mul(ray.d, t.t1));
+// Função para calcular a interseção de um raio com um triângulo
+double rayTriangleIntersect(Vec3 rayOrigin, Vec3 rayDirection, Vec3 v0, Vec3 v1, Vec3 v2) {
+    Vec3 edge1 = Sub(v1, v0);
+    Vec3 edge2 = Sub(v2, v0);
+    Vec3 h = Cross(rayDirection, edge2);
+    double a = Dot(edge1, h);
+    if (a > -0.00001 && a < 0.00001)
+        return(INFINITY);
+    double f = 1.0/a;
+    Vec3 s = Sub(rayOrigin, v0);
+    double u = f * Dot(s, h);
+    if (u < 0.0 || u > 1.0)
+        return(INFINITY);
+    Vec3 q = Cross(s, edge1);
+    double v = f * Dot(rayDirection, q);
+    if (v < 0.0 || u + v > 1.0)
+        return(INFINITY);
+    // At this stage we can compute t to find out where the intersection point is on the line.
+    double t = f * Dot(edge2, q);
+    if (t > 0.00001) // ray intersection
+        return t;
+    else // This means that there is a line intersection but not a ray intersection.
+        return INFINITY;
+}
 
-    if (!isWithinBounds(paraboloid, intersection1) || isWithinTopDisk(paraboloid, intersection1)) {
-        t.t0 = -1;
+// Função para calcular a interseção de um raio com uma pirâmide
+// Função para calcular a interseção de um raio com uma pirâmide
+tValues pyramidCollision(Pyramid *pyramid, Ray ray) {
+    tValues result;
+    result.t0 = INFINITY;
+    result.t1 = INFINITY;
+
+    // Agora temos 5 faces na pirâmide, incluindo a base.
+    // Agora temos 4 faces na pirâmide, excluindo a base.
+for (int i = 1; i <= 4; i++) {
+    // Cada face da pirâmide é um triângulo formado por três vértices.
+    Vec3 v0 = pyramid->vertices[0]; // Top vertex is common for all faces
+    Vec3 v1 = pyramid->vertices[i];
+    Vec3 v2 = pyramid->vertices[i % 4 + 1]; // Changed from (i + 2) % 5 to i % 4 + 1
+
+    // Calcula a interseção do raio com o triângulo.
+    double t = rayTriangleIntersect(ray.o, ray.d, v0, v1, v2);
+
+    // Se o raio intersecta o triângulo e a interseção está mais próxima do que a interseção atual,
+    // atualiza a interseção e a normal.
+    if (t < result.t0) {
+        result.t0 = t;
+        result.normal0 = pyramid->normals[i-1];
+        }
     }
 
-    if (!isWithinBounds(paraboloid, intersection2) || isWithinTopDisk(paraboloid, intersection2)) {
-        t.t1 = -1;
+    // Check intersection with the base of the pyramid
+    Vec3 v0 = pyramid->vertices[1];
+    Vec3 v1 = pyramid->vertices[2];
+    Vec3 v2 = pyramid->vertices[3];
+    Vec3 v3 = pyramid->vertices[4];
+    double t1 = rayTriangleIntersect(ray.o, ray.d, v0, v1, v3); // Changed v2 to v3
+    double t2 = rayTriangleIntersect(ray.o, ray.d, v1, v2, v3); // Changed v0 to v1
+    double t = (t1 < t2) ? t1 : t2;
+    if (t < result.t0) {
+        result.t0 = t;
+        result.normal0 = pyramid->normals[4];
     }
 
-    return t;
+    return result;
 }
\ No newline at end of file
diff --git a/src/Objects/Create.c b/src/Objects/Create.c
index 097f2d7..8e394b2 100644
--- a/src/Objects/Create.c
+++ b/src/Objects/Create.c
@@ -1,190 +1,119 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   Create.c                                           :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/12 16:35:54 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/12 20:26:34 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
 #include <center.h>
 
-double	getfloat(char *prop, bool required, float *range, int standard_value);
-Vec3	getVec4(char *prop, bool required, float max, float min);
-void	updateError(char *msg);
-
-void	*object_error_handler(Object *obj, void **ptr, char *msg)
-{
-	delprops((char **) ptr);
-	if (g_scene->error)
-	{
-		if (msg)
-			updateError(msg);
-		return (free(obj), NULL);
-	}
-	return ((void *)obj);
-}
-
-Object	*newObject(size_t targetsize, tValues (*colision)(struct Object *, Ray))
-{
-	Object	*obj;
-
-	(obj) = ft_calloc(targetsize, 1);
-	(obj)->colision = colision;
-	(obj)->d = (Vec3){0, 0, 0};
-	(obj)->next = NULL;
-	return (obj);
+Object *newObject(size_t ModelType, Vec3 o, Vec3 d, Vec4 color, Vec3 theta){
+	Object *obj = calloc(ModelType, 1);
+	obj->o = o;
+	obj->d = d;
+	obj->color = rgbGetter(color.r, color.g, color.b);
+	obj->theta = theta;
+	obj->next = NULL;
+	obj->colision = NULL;
+	return obj;
 }
 
-Sphere	*newSphere(int type, char **props){
-	Sphere	*s;
-	Vec3	color;
-
-	s = (Sphere *)newObject(sizeof(Sphere), spherecolision);
-	s->o = getVec4(props[1], true, INT16_MAX, -INT16_MAX);
-	s->diameter = getfloat(props[2], true, (float []){INT16_MAX / 3, 0}, 1);
-	color = getVec4(props[3], true, 255, 0);
-	s->color = newrgb((int)color.x, (int)color.y, (int)color.z);
-	s->type = type;
-	if (props[4])
-	{
-		s->specular = (int)getfloat(props[4], true, (float []){1000, 0}, 1);
-		if(!g_scene->error)
-			s->reflection = getfloat(props[5], true, (float []){1, 0}, 0);
-	}
-	s->next = NULL;
-	return 	((Sphere *)object_error_handler((Object *)s, (void **)props, "-> Invalid sphere"));
+Sphere *newSphere(Vec3 o, Vec3 d, Vec4 color, Vec3 theta, double diameter, tValues (*colision)(), double reflec, double specular){	Sphere *s = (Sphere *)newObject(sizeof(Sphere), o, d, color, theta);
+	s->diameter = diameter;
+	s->type = SPHERE;
+	s->colision = colision;
+    s->reflection = reflec;
+    s->specular = specular;
+    s->color =(int)(color.r) << 16 | (int)(color.g) << 8 | (int)(color.b);
+	return s;
 }
 
-Plane	*newPlane(int type, char **props){
-	Vec3	color;
-	Plane	*p;
-
-	p = (Plane *)newObject(sizeof(Plane), \
-		(tValues (*)(struct Object *, struct Ray))planecolision);
-	p->type = type;
-	p->o = getVec4(props[1], true, INT16_MAX, -INT16_MAX);
-	p->d = getVec4(props[2], true, 1, -1);
-	color = getVec4(props[3], true, 255, 0);
-	p->color = newrgb((int)color.x, (int)color.y, (int)color.z);
-	if (props[4])
-	{
-		p->specular = getfloat(props[4], true, (float []){1000, 0}, 0);
-		p->reflection = getfloat(props[5], true, (float []){1, 0}, 0);
-		p->checkerboard = getfloat(props[6], true, (float []){1, 0}, 0);
-	}
-	p->next = NULL;
-	return ((Plane *)object_error_handler((Object *)p, \
-		(void **)props, "-> Invalid plane"));
+Plane *newPlane(Vec3 o, Vec3 d, Vec4 color, Vec3 theta, float size, tValues (*colision)(), double reflec, double specular, int checkerboard){	Plane *p = (Plane *)newObject(sizeof(Plane), o, d, color, theta);
+	p->size = size;
+	p->type = PLANE;
+	p->colision = colision;
+    p->reflection = reflec;
+    p->specular = specular;
+    p->checkerboard = checkerboard;
+	return p;
 }
 
-static void	setup_am(char **p, Light *l)
-{
-	Vec3	color;
-
-	printf("Error: %d\n", g_scene->error);
-	l->i = getfloat(p[1], true, (float []){1, 0}, 0);
-	printf("Error: %d\n", g_scene->error);
-	color = getVec4(p[2], true, 255, 0);
-	printf("Error: %d\n", g_scene->error);
-	l->color = newrgb((int)color.x, (int)color.y, (int)color.z);
-	l->next = NULL;
+Camera *newCamera(Vec3 o, Vec3 d, double fov, Vec3 theta){	Camera *c = (Camera *)calloc(1, sizeof(Camera));
+	c->o = o;
+	c->d = d;
+	c->fov = fov;
+	c->theta = theta;
+	c->type = CAMERA;
+    c->aspectRatio = scene->width / scene->height;
+    c->height = (tan(c->fov / 2 * M_PI / 180) * 2);
+    c->width = c->height * c->aspectRatio;
+	return c;
 }
 
-// SECTION - POINT LIGHT
-static void	setup_p(char **p, Light *l)
+Light *newLight(Vec3 o, Vec3 d, Vec4 color, Vec3 theta, double intensity, int type)
 {
-	Vec3	color;
 
-	l->o = getVec4(p[1], true, INT16_MAX, -INT16_MAX);
-	l->i = getfloat(p[2], true, (float []){1, 0}, 0);
-	color = getVec4(p[3], true, 255, 0);
-	l->color = newrgb((int)color.x, (int)color.y, (int)color.z);
-}
-
-Light	*newlight(int type, char **props)
-{
-	Light	*l;
+	Light *l = (Light *)newObject(sizeof(Light), o, d, color, theta);
 
-	l = (Light *)newObject(sizeof(Light), NULL);
+	l->intensity = intensity;
 	l->type = type;
-	if (type == POINT)
-		setup_p(props, l);
-	else if (type == AMBIENT)
-		setup_am(props, l);
-	l->next = NULL;
-	return ((Light *)object_error_handler((Object *)l, (void **)props, "-> Invalid Light"));
+	return l;
 }
 
-Cylinder	*newCylinder(int type, char **props){
-	Vec3		color;
-	Cylinder	*c;
-
-	c = (Cylinder *)newObject(sizeof(Cylinder), \
-		(tValues (*)(struct Object *, struct Ray))cylindercolision);
-	c->type = CYLINDER;
-	c->type = type;
-	c->o = getVec4(props[1], true, INT16_MAX, -INT16_MAX);
-	c->d = norm(getVec4(props[2], true, 1, -1));
-	c->diameter = getfloat(props[3], true, (float []){INT16_MAX / 3, 0}, 1);
-	c->height = getfloat(props[4], true, (float []){INT16_MAX / 3, 0}, 1);
-	color = getVec4(props[5], true, 255, 0);
-	c->color = newrgb((int)color.x, (int)color.y, (int)color.z);
-	c->colision = (tValues (*)(struct Object *, struct Ray))cylindercolision;
-	if (props[6])
-	{
-		c->specular = getfloat(props[6], true, (float []){1000, 0}, 0);
-		c->reflection = getfloat(props[7], true, (float []){1, 0}, 0);
-	}
-	return ((Cylinder *)object_error_handler((Object *)c, \
-		(void **)props, "-> Invalid Cylinder"));
+Cylinder *newCylinder(Vec3 o, Vec3 d, double diameter, double height, Vec4 color, Vec3 theta, tValues (*colision)(), double reflec, double specular){
+    Cylinder *c = (Cylinder *)newObject(sizeof(Cylinder), o, d, color, theta);
+    c->diameter = diameter;
+    c->height = height;
+    c->type = CYLINDER;
+    c->colision = colision;
+    c->reflection = reflec;
+    c->specular = specular;
+    return c;
 }
 
-Camera	*newCamera(int type, char **props)
-{
-	Camera	*c;
-
-	c = (Camera *)newObject(sizeof(Camera), NULL);
-	c->type = CAMERA;
-	c->o = getVec4(props[1], true, INT16_MAX, -INT16_MAX);
-	c->d = getVec4(props[2], true, 1, -1);
-	c->theta = getVec4("0,0,0", true, 1, -1);
-	c->fov = getfloat(props[3], true, (float []){180, 0}, 1);
-	c->aspect = (double)g_scene->width / (double)g_scene->height;
-	c->height = tan(c->fov / 2 * M_PI / 180);
-	c->width = c->aspect * c->height;
-	c->next = NULL;
-	return ((Camera *)object_error_handler((Object *)c, (void **)props, \
-		"-> Invalid Camera"));
+Vec3 calculateNormal(Vec3 v0, Vec3 v1, Vec3 v2) {
+    Vec3 edge1 = Sub(v1, v0);
+    Vec3 edge2 = Sub(v2, v0);
+    Vec3 normal = Cross(edge1, edge2);
+    return Normalize(normal);
 }
 
-Paraboloid	*newParaboloid(int type, char **props)
+Pyramid *newPyramid(Vec3 o, Vec3 d, double width, double height, Vec4 color, double angle, tValues (*colision)(), double reflec, double specular)
 {
-	Paraboloid	*paraboloid;
-	Vec3		color;
-
-	paraboloid = (Paraboloid *)newObject(sizeof(Paraboloid), \
-		(tValues (*)(struct Object *, struct Ray))paraboloidCollision);
-	if (!paraboloid)
-		return (NULL);
-	paraboloid->o = getVec4(props[1], true, INT16_MAX, -INT16_MAX);
-	paraboloid->height = getfloat(props[2], true, (float []){INT16_MAX / 3, \
-		0}, 1);
-	paraboloid->diameter = getfloat(props[3], true, (float []){INT16_MAX / 3, \
-		0}, 1);
-	paraboloid->p = 1;
-	color = getVec4(props[4], true, 255, 0);
-	paraboloid->type = type;
-	paraboloid->color = newrgb((int)color.x, (int)color.y, (int)color.z);
-	if (props[5])
-	{
-		paraboloid->specular = getfloat(props[5], true, (float []){1000, 0}, 1);
-		if (!g_scene->error)
-			paraboloid->reflection = getfloat(props[6], true, (float []){1, 0}, 0);
-	}
-	return ((Paraboloid *)object_error_handler((Object *)paraboloid, \
-	(void **)props, "-> Invalid Paraboloid"));
+    Vec3 rotation = {0, angle, 0}; // Rotate around the y-axis
+    Pyramid *p = (Pyramid *)newObject(sizeof(Pyramid), o, d, color, rotation);
+    p->width = width;
+    p->height = height;
+    p->type = PYRAMID;
+    p->colision = colision;
+    p->reflection = reflec;
+    p->specular = specular;
+
+    // Define os vértices da pirâmide.
+    double halfWidth = width / 2;
+    p->vertices[0] = (Vec3){0, height, 0}; // Top vertex
+    p->vertices[1] = (Vec3){-halfWidth, 0, -halfWidth}; // Base vertices
+    p->vertices[2] = (Vec3){halfWidth, 0, -halfWidth};
+    p->vertices[3] = (Vec3){halfWidth, 0, halfWidth};
+    p->vertices[4] = (Vec3){-halfWidth, 0, halfWidth};
+
+    // Rotate the vertices according to the direction
+    for (int i = 0; i < 5; i++) {
+        p->vertices[i] = rotate(p->vertices[i], d, angle);
+        p->vertices[i] = Add(p->vertices[i], o); // Add the base center position back
+    }
+
+    // Define as normais das faces da pirâmide.
+    for (int i = 1; i <= 4; i++) {
+        Vec3 v0 = p->vertices[0];
+        Vec3 v1 = p->vertices[i];
+        Vec3 v2 = p->vertices[i % 4 + 1];
+        p->normals[i-1] = calculateNormal(v0, v1, v2);
+    }
+
+    // Define os vértices e normais dos triângulos da base.
+    p->vertices[5] = p->vertices[1];
+    p->vertices[6] = p->vertices[2];
+    p->vertices[7] = p->vertices[3];
+    p->normals[4] = calculateNormal(p->vertices[5], p->vertices[6], p->vertices[7]);
+
+    p->vertices[8] = p->vertices[1];
+    p->vertices[9] = p->vertices[3];
+    p->vertices[10] = p->vertices[4];
+    p->normals[5] = calculateNormal(p->vertices[8], p->vertices[9], p->vertices[10]);
+    p->reflection = reflec;
+    return p;
 }
\ No newline at end of file
diff --git a/src/Objects/cylinderColision.c b/src/Objects/cylinderColision.c
deleted file mode 100644
index 58ff167..0000000
--- a/src/Objects/cylinderColision.c
+++ /dev/null
@@ -1,76 +0,0 @@
-#include <center.h>
-
-tValues	quadraticsolver(double a, double b, double c)
-{
-	tValues		t;
-	double		discriminant;
-
-	discriminant = b * b - 4 * a * c;
-	if (discriminant > 0)
-		return ((tValues){(\
-			-b - sqrt(discriminant)) / \
-			(2 * a), (-b + sqrt(discriminant)) / \
-			(2 * a)});
-	return ((tValues){INFINITY, INFINITY});
-}
-
-tValues	planecolisioncylinder(Vec3 planep, Vec3 planen, Ray ray, double radius)
-{
-	tValues	t;
-	double	denominador;
-	double	numerator;
-	Vec3	intersectionpoint;
-	double	distance;
-
-	denominador = dot(ray.d, planen);
-	if (fabs(denominador) < 0.001)
-	{
-		t.t0 = INFINITY;
-		t.t1 = INFINITY;
-		return (t);
-	}
-	numerator = dot(sub(planep, ray.o), planen);
-	t.t0 = numerator / denominador;
-	t.t1 = INFINITY;
-	intersectionpoint = add(ray.o, mul(ray.d, t.t0));
-	distance = len(sub(intersectionpoint, planep));
-	if (distance > radius)
-		t.t0 = INFINITY;
-	return (t);
-}
-
-tValues	calculatetvalues(Vec3 oc, Ray ray, Cylinder *cylinder)
-{
-	tValues	t;
-	double	radius;
-
-	radius = cylinder->diameter / 2;
-	return (quadraticsolver(dot(ray.d, ray.d) - dot(ray.d, cylinder->d) \
-		* dot(ray.d, cylinder->d) \
-		, 2 * (dot(ray.d, oc) - dot(ray.d, cylinder->d) * \
-		dot(oc, cylinder->d)) \
-		, dot(oc, oc) - dot(oc, cylinder->d) * dot(oc, cylinder->d) \
-		- radius * radius));
-}
-
-void	checkheight(tValues *t, Vec3 p1, Vec3 p2, Cylinder *cylinder)
-{
-	double	h1;
-	double	h2;
-
-	h1 = dot(sub(p1, cylinder->o), cylinder->d);
-	h2 = dot(sub(p2, cylinder->o), cylinder->d);
-	if (h1 < 0 || h1 > cylinder->height)
-		t->t0 = INFINITY;
-	if (h2 < 0 || h2 > cylinder->height)
-		t->t1 = INFINITY;
-}
-
-tValues	calculatetopplanecolision(Ray ray, Cylinder *cylinder)
-{
-	Vec3	topcenter;
-
-	topcenter = add(cylinder->o, mul(cylinder->d, cylinder->height));
-	return (planecolisioncylinder(topcenter, cylinder->d, ray, \
-	cylinder->diameter / 2));
-}
diff --git a/src/Objects/cylinderColision2.c b/src/Objects/cylinderColision2.c
deleted file mode 100644
index a051d79..0000000
--- a/src/Objects/cylinderColision2.c
+++ /dev/null
@@ -1,54 +0,0 @@
-#include <center.h>
-
-tValues	calculatebotplanecolision(Ray ray, Cylinder *cylinder)
-{
-	Vec3	botcenter;
-
-	botcenter = cylinder->o;
-	return (planecolisioncylinder(botcenter, cylinder->d, ray, \
-	cylinder->diameter / 2));
-}
-
-tValues	calculateplanecolisions(Ray ray, Cylinder *cylinder)
-{
-	tValues	top;
-	tValues	bot;
-	tValues	result;
-
-	top = calculatetopplanecolision(ray, cylinder);
-	bot = calculatebotplanecolision(ray, cylinder);
-	result.t0 = minval(top.t0, bot.t0);
-	result.t1 = INFINITY;
-	return (result);
-}
-
-Vec3	calculatenormalone(tValues t, Vec3 p1, Cylinder *cylinder)
-{
-	Vec3	normal;
-	double	dotc;
-
-	normal = sub(p1, cylinder->o);
-	dotc = dot(normal, cylinder->d);
-	return (norm(sub(normal, mul(cylinder->d, dotc))));
-}
-
-Vec3	calculatenormaltwo(tValues t, Vec3 p2, Cylinder *cylinder)
-{
-	Vec3	normal;
-	double	dotc;
-
-	normal = sub(p2, cylinder->o);
-	dotc = dot(normal, cylinder->d);
-	return (norm(sub(normal, mul(cylinder->d, dotc))));
-}
-
-tValues	calculatenormals(tValues t, Vec3 p1, Vec3 p2, Cylinder *cylinder)
-{
-	tValues	result;
-
-	result.t0 = t.t0;
-	result.t1 = t.t1;
-	result.normal0 = calculatenormalone(t, p1, cylinder);
-	result.normal1 = calculatenormaltwo(t, p2, cylinder);
-	return (result);
-}
diff --git a/src/Objects/cylinderColision3.c b/src/Objects/cylinderColision3.c
deleted file mode 100644
index e100e74..0000000
--- a/src/Objects/cylinderColision3.c
+++ /dev/null
@@ -1,19 +0,0 @@
-#include <center.h>
-
-tValues	cylindercolision(Cylinder *cylinder, Ray ray)
-{
-	Vec3	oc;
-	tValues	t;
-	Vec3	p1;
-	Vec3	p2;
-	tValues	planecolisions;
-
-	oc = sub(ray.o, cylinder->o);
-	t = calculatetvalues(oc, ray, cylinder);
-	p1 = add(ray.o, mul(ray.d, t.t0));
-	p2 = add(ray.o, mul(ray.d, t.t1));
-	checkheight(&t, p1, p2, cylinder);
-	planecolisions = calculateplanecolisions(ray, cylinder);
-	t.t0 = minval(t.t0, planecolisions.t0);
-	return (calculatenormals(t, p1, p2, cylinder));
-}
diff --git a/src/ParseFunctions/Parse.utils.c b/src/ParseFunctions/Parse.utils.c
deleted file mode 100644
index 68d6746..0000000
--- a/src/ParseFunctions/Parse.utils.c
+++ /dev/null
@@ -1,37 +0,0 @@
-#include <center.h>
-
-void	delprops(char **line)
-{
-	int	i;
-
-	i = 0;
-	while (line[++i])
-		free(line[i]);
-	free(line);
-}
-
-bool	generateobject(char **props)
-{
-	int	type;
-
-	type = UNKNOWN;
-	if (ft_strncmp(props[0], "sp", 6) == 0)
-		type = SPHERE;
-	else if (ft_strncmp(props[0], "pl", 5) == 0)
-		type = PLANE;
-	else if (ft_strncmp(props[0], "C", 6) == 0)
-		type = CAMERA;
-	else if (ft_strncmp(props[0], "L", 5) == 0)
-		type = POINT;
-	else if (ft_strncmp(props[0], "A", 7) == 0)
-		type = AMBIENT;
-	else if (ft_strncmp(props[0], "D", 12) == 0)
-		type = DIRECTIONAL;
-	else if (ft_strncmp(props[0], "cy", 8) == 0)
-		type = CYLINDER;
-	else if (ft_strncmp(props[0], "pa", 7) == 0)
-		type = PARABOLOID;
-	if (!distributeobject(type, props))
-		return (false);
-	return (true);
-}
\ No newline at end of file
diff --git a/src/ParseFunctions/generate.c b/src/ParseFunctions/generate.c
deleted file mode 100644
index 6c821df..0000000
--- a/src/ParseFunctions/generate.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   generate.c                                         :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/12 19:12:01 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/12 19:12:54 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-bool	distributeobject(int type, char **props)
-{
-	if (type == UNKNOWN)
-		return (updateError("Unknown object type"), delprops(props), false);
-	if (type == SPHERE)
-		objectadd((Object *)newSphere(type, props), (void **)&g_scene->objects);
-	if (type == PLANE)
-		objectadd((Object *)newPlane(type, props), (void **)&g_scene->objects);
-	if (type == CAMERA)
-		objectadd((Object *)newCamera(type, props), (void **)&g_scene->camera);
-	if (type == POINT)
-		objectadd((Object *)newlight(type, props), (void **)&g_scene->lights);
-	if (type == AMBIENT)
-		objectadd((Object *)newlight(type, props), (void **)&g_scene->am);
-	if (type == CYLINDER)
-		objectadd((Object *)newCylinder(type, props),
-			(void **)&g_scene->objects);
-	if (type == PARABOLOID)
-		objectadd((Object *)newParaboloid(type, props),
-			(void **)&g_scene->objects);
-	return (true);
-}
-
-/*ANCHOR - 
-	Norminette: OK
-	Compilation: OK
-	Tests: OK
-*/
\ No newline at end of file
diff --git a/src/ParseFunctions/parse.c b/src/ParseFunctions/parse.c
deleted file mode 100644
index c08d07c..0000000
--- a/src/ParseFunctions/parse.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ParseFunctions.c                                            :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 12:33:27 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/10 17:12:11 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-char	**getpropreties(char **line)
-{
-	char	**props;
-	int		i;
-
-	i = -1;
-	props = NULL;
-	while ((*line)[++i])
-		if (((*line)[i]) == ' ' || ((*line)[i]) == '\t')
-			(*line)[i] = ' ';
-	props = ft_split((*line), ' ');
-	return (props);
-}
-
-bool	fetchdata(int fd)
-{
-	char	*line;
-	char	**props;
-
-	line = NULL;
-	while (true)
-	{
-		free(line);
-		line = get_next_line(fd);
-		if (!line)
-			break ;
-		if (ft_strnstr(line, "#", ft_strlen(line)) || line[0] == '\n'
-			|| line[0] == '\0')
-			continue ;
-		props = getpropreties(&line);
-		if (!props)
-			return (updateError("Error getting properties"), false);
-		if (generateobject(props) == false)
-			return (updateError("Error generating object"), false);
-		if (g_scene->error)
-			return (false);
-	}
-	return (true);
-}
-
-bool	parse(char *f)
-{
-	int	file;
-
-	if (!f || (ft_strnstr(f, ".rt", ft_strlen(f)) == NULL))
-		return (updateError("Error file extension"), false);
-	file = open(f, O_RDONLY);
-	if (file < 0)
-		return (updateError("Error opening file"), false);
-	if (!fetchdata(file))
-		return (updateError("Error fetching data"), close(file), false);
-	close(file);
-	return (true);
-}
diff --git a/src/ReflectionsAndLights/init.c b/src/ReflectionsAndLights/init.c
deleted file mode 100644
index 523d614..0000000
--- a/src/ReflectionsAndLights/init.c
+++ /dev/null
@@ -1,65 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   init.c                                             :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 11:18:22 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/12 20:50:05 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-double	refl(Vec3 data, Vec3 reflected, Vec3 vect)
-{
-	double	bright;
-	double	length_reflected;
-	double	length_vect;
-
-	length_reflected = sqrt(reflected.x * reflected.x + reflected.y * \
-	reflected.y + reflected.z * reflected.z);
-	length_vect = sqrt(vect.x * vect.x + vect.y * vect.y + vect.z * vect.z);
-	bright = data.x * pow(data.y / (length_reflected * length_vect), data.z);
-	return (bright);
-}
-
-void	diffusion(Vec4 *combined, Vec3 normal, Vec3 light, Light *src)
-{
-	double	n_dot_l;
-	double	bright;
-
-	n_dot_l = dot(normal, light);
-	if (n_dot_l > 0)
-	{
-		bright = src->i * n_dot_l / (len(normal) * len(light));
-		calc_combined(combined, src->color, bright);
-	}
-}
-
-Vec4	calcligh(Vec3 p, Vec3 n, Vec3 v, double spec)
-{
-	Vec4	c;
-	double	rdv;
-	Light	*l;
-	Vec3	pvl;
-	Vec3	reflected;
-
-	c = (Vec4){0, 0, 0};
-	l = g_scene->lights;
-	calc_combined(&c, g_scene->am->color, g_scene->am->i);
-	while (l)
-	{
-		pvl = sub(l->o, p);
-		if (shadow(p, norm(pvl), 0.001, 1) && skip(&l))
-			continue ;
-		diffusion(&c, n, pvl, l);
-		rdv = to_reflect(l->o, n, v, &reflected);
-		if (spec > 0 && rdv > 0)
-			calc_combined(&c, l->color, refl((Vec3){(l->i / (len(pvl) * \
-				len(pvl))), rdv, spec}, reflected, v));
-		l = (Light *)l->next;
-	}
-	return (limit(c));
-}
diff --git a/src/ReflectionsAndLights/utils.1.c b/src/ReflectionsAndLights/utils.1.c
deleted file mode 100644
index 0c5b04b..0000000
--- a/src/ReflectionsAndLights/utils.1.c
+++ /dev/null
@@ -1,48 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   utils.1.c                                          :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 11:14:30 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/08 11:33:52 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-Vec3	reflect_ray(Vec3 light, Vec3 normal);
-
-double	to_reflect(Vec3 light, Vec3 n, Vec3 vect, Vec3 *reflected)
-{
-	double	r_dot_v;
-
-	*reflected = reflect_ray(light, n);
-	r_dot_v = reflected->x * vect.x + reflected->y * vect.y + reflected->z
-		* vect.z;
-	return (r_dot_v);
-}
-
-Vec4	limit(Vec4 v)
-{
-	if (v.r > 1)
-		v.r = 1;
-	if (v.g > 1)
-		v.g = 1;
-	if (v.b > 1)
-		v.b = 1;
-	if (v.r < 0)
-		v.r = 0;
-	if (v.g < 0)
-		v.g = 0;
-	if (v.b < 0)
-		v.b = 0;
-	return (v);
-}
-
-int	skip(Light **l)
-{
-	*l = (Light *)(*l)->next;
-	return (1);
-}
diff --git a/src/ReflectionsAndLights/utils.c b/src/ReflectionsAndLights/utils.c
deleted file mode 100644
index 3548297..0000000
--- a/src/ReflectionsAndLights/utils.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   utils.c                                            :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 00:03:09 by psoares-          #+#    #+#             */
-/*   Updated: 2024/02/12 17:06:33 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-static void	setdata(Object *obj, Ray *ray)
-{
-	ray->normal = normalcalc(obj, add(ray->o, mul(ray->d, ray->ct)));
-	ray->_hit = add(ray->o, mul(ray->d, ray->ct));
-}
-
-Vec3	reflect_ray(Vec3 light, Vec3 normal)
-{
-	Vec3	result;
-	double	dot_product;
-
-	dot_product = normal.x * light.x + normal.y * light.y + normal.z * light.z;
-	result.x = light.x - 2 * normal.x * dot_product;
-	result.y = light.y - 2 * normal.y * dot_product;
-	result.z = light.z - 2 * normal.z * dot_product;
-	return (result);
-}
-
-int	shadow(Vec3 origin, Vec3 dir, double t_min, double t_max)
-{
-	Object	*temp;
-	tValues	t;
-
-	temp = g_scene->objects;
-	while (temp)
-	{
-		t = temp->colision(temp, (Ray){origin, dir});
-		if (t.t0 > t_min && t.t0 < t_max)
-			return (1);
-		if (t.t1 > t_min && t.t1 < t_max)
-			return (1);
-		temp = temp->next;
-	}
-	return (0);
-}
-
-Object	*intersections(Ray *rt, double md, double d, bool set)
-{
-	Object	*closest;
-	Object	*o;
-
-	rt->ct = INFINITY;
-	closest = NULL;
-	o = g_scene->objects;
-	while (o)
-	{
-		//printf("o->type: %d\n", o->type);
-		rt->val = o->colision(o, *rt);
-		if ((rt->val.t0 > d && rt->val.t0 < md) && rt->val.t0 < rt->ct)
-		{
-			closest = o;
-			rt->ct = rt->val.t0;
-		}
-		else if ((rt->val.t1 > d && rt->val.t1 < md) && rt->val.t1 < rt->ct)
-		{
-			closest = o;
-			rt->ct = rt->val.t1;
-		}
-		o = o->next;
-	}
-	if (set)
-		setdata(closest, rt);
-	return (closest);
-}
diff --git a/src/TextureRender/utils.c b/src/TextureRender/utils.c
deleted file mode 100644
index 12e9c7f..0000000
--- a/src/TextureRender/utils.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   utils.c                                            :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 11:12:42 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/08 11:12:50 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-Vec4	checkerboardColor(Vec3 point, Vec4 color1, Vec4 color2, double size)
-{
-	if ((int)(floor(point.x / size) + floor(point.y / size) + floor(point.z \
-				/ size)) % 2 == 0)
-		return (color1);
-	else
-		return (color2);
-}
\ No newline at end of file
diff --git a/src/Vector/Operators.c b/src/Vector/Operators.c
index 5991a85..f997017 100644
--- a/src/Vector/Operators.c
+++ b/src/Vector/Operators.c
@@ -1,41 +1,90 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   Operators.c                                        :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 00:04:30 by psoares-          #+#    #+#             */
-/*   Updated: 2024/02/08 10:58:46 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
 #include "center.h"
 
-double	dot(Vec3 a, Vec3 b)
-{
-	return (a.x * b.x + a.y * b.y + a.z * b.z);
+double Dot(Vec3 a, Vec3 b){
+    return a.x * b.x + a.y * b.y + a.z * b.z;
 }
 
-double	len(Vec3 v)
-{
-	return (sqrt(dot(v, v)));
+double Length(Vec3 v){
+    return sqrt(Dot(v, v));
 }
 
-Vec3	norm(Vec3 v)
-{
-	double	nor;
+Vec3 Normalize(Vec3 v){
+    double len = Length(v);
+    return (Vec3){v.x / len, v.y / len, v.z / len};
+}
 
-	nor = len(v);
-	return ((Vec3){v.x / nor, v.y / nor, v.z / nor});
+Vec3 Add(Vec3 a, Vec3 b){
+    return (Vec3){a.x + b.x, a.y + b.y, a.z + b.z};
+}
+Vec3 Sub(Vec3 a, Vec3 b){
+    return (Vec3){a.x - b.x, a.y - b.y, a.z - b.z};
+}
+Vec3 Mul(Vec3 a, double b){
+    return (Vec3){a.x * b, a.y * b, a.z * b};
+}
+Vec3 Div(Vec3 a, double b){
+    return (Vec3){a.x / b, a.y / b, a.z / b};
 }
 
-Vec3	add(Vec3 a, Vec3 b)
-{
-	return ((Vec3){a.x + b.x, a.y + b.y, a.z + b.z});
+Vec3 unitVector(Vec3 v){
+	double len = Length(v);
+	return (Vec3){v.x / len, v.y / len, v.z / len};
+}
+
+Vec3 Cross(Vec3 a, Vec3 b){    return (Vec3){a.y * b.z - a.z * b.y,
+                  a.z * b.x - a.x * b.z,
+                  a.x * b.y - a.y * b.x};
 }
 
-Vec3	sub(Vec3 a, Vec3 b)
+
+
+Vec4 Add4(Vec4 a, Vec4 b) {
+    Vec4 result;
+    result.r = Min(a.r + b.r, 255);
+    result.g = Min(a.g + b.g, 255);
+    result.b = Min(a.b + b.b, 255);
+    return result;
+}
+
+Vec4 Mul4(Vec4 a, double b) {
+    Vec4 result;
+    result.r = a.r * b;
+    result.g = a.g * b;
+    result.b = a.b * b;
+    return result;
+}
+
+Vec3 randomDirection()
 {
-	return ((Vec3){a.x - b.x, a.y - b.y, a.z - b.z});
+    while (true) {
+        Vec3 D;
+        D.x = randomLimited(-1, 1);
+        D.y = randomLimited(-1, 1);
+        D.z = randomLimited(-1, 1);
+        if(Length(D) < 0)
+            return D;
+    }
 }
+
+Vec3 Reflect(Vec3 incident, Vec3 normal) {
+    return Sub(incident, Mul(normal, 2 * Dot(incident, normal)));
+}
+
+Vec3 rotate(Vec3 point, Vec3 axis, double angle) {
+    double cosTheta = cos(angle);
+    double sinTheta = sin(angle);
+    Vec3 u = Normalize(axis);
+
+    Vec3 rotatedPoint;
+    rotatedPoint.x = (cosTheta + u.x * u.x * (1 - cosTheta)) * point.x
+                   + (u.x * u.y * (1 - cosTheta) - u.z * sinTheta) * point.y
+                   + (u.x * u.z * (1 - cosTheta) + u.y * sinTheta) * point.z;
+    rotatedPoint.y = (u.y * u.x * (1 - cosTheta) + u.z * sinTheta) * point.x
+                   + (cosTheta + u.y * u.y * (1 - cosTheta)) * point.y
+                   + (u.y * u.z * (1 - cosTheta) - u.x * sinTheta) * point.z;
+    rotatedPoint.z = (u.z * u.x * (1 - cosTheta) - u.y * sinTheta) * point.x
+                   + (u.z * u.y * (1 - cosTheta) + u.x * sinTheta) * point.y
+                   + (cosTheta + u.z * u.z * (1 - cosTheta)) * point.z;
+
+    return rotatedPoint;
+}
\ No newline at end of file
diff --git a/src/Vector/Operators2.c b/src/Vector/Operators2.c
deleted file mode 100644
index 1e9f778..0000000
--- a/src/Vector/Operators2.c
+++ /dev/null
@@ -1,47 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   Operators2.c                                       :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 00:18:23 by psoares-          #+#    #+#             */
-/*   Updated: 2024/02/08 10:59:48 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-Vec3	mul(Vec3 a, double b)
-{
-	return ((Vec3){a.x * b, a.y * b, a.z * b});
-}
-
-Vec3	divv(Vec3 a, double b)
-{
-	return ((Vec3){a.x / b, a.y / b, a.z / b});
-}
-
-Vec3	unitvector(Vec3 v)
-{
-	double	l;
-
-	l = len(v);
-	return ((Vec3){v.x / l, v.y / l, v.z / l});
-}
-
-Vec3	cross(Vec3 a, Vec3 b)
-{
-	return ((Vec3){a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, \
-	a.x * b.y - a.y * b.x});
-}
-
-Vec4	add4(Vec4 a, Vec4 b)
-{
-	Vec4	result;
-
-	result.r = minval(a.r + b.r, 255);
-	result.g = minval(a.g + b.g, 255);
-	result.b = minval(a.b + b.b, 255);
-	return (result);
-}
diff --git a/src/Vector/Operators3.c b/src/Vector/Operators3.c
deleted file mode 100644
index 5ac6671..0000000
--- a/src/Vector/Operators3.c
+++ /dev/null
@@ -1,50 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   Operators3.c                                       :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 00:26:52 by psoares-          #+#    #+#             */
-/*   Updated: 2024/02/08 11:01:47 by pedro            ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-Vec4	mul4(Vec4 a, double b)
-{
-	Vec4	result;
-
-	result.r = a.r * b;
-	result.g = a.g * b;
-	result.b = a.b * b;
-	return (result);
-}
-
-Vec3	reflect(Vec3 incident, Vec3 normal)
-{
-	return (sub(incident, mul(normal, 2 * dot(incident, normal))));
-}
-
-Vec3	rotate(Vec3 point, Vec3 axis, double angle)
-{
-	double	costheta;
-	double	sintheta;
-	Vec3	u;
-	Vec3	rotatedpoint;
-
-	costheta = cos(angle);
-	sintheta = sin(angle);
-	u = norm(axis);
-	rotatedpoint.x = (costheta + u.x * u.x * (1 - costheta)) * point.x \
-	+ (u.x * u.y * (1 - costheta) - u.z * sintheta) * point.y \
-	+ (u.x * u.z * (1 - costheta) + u.y * sintheta) * point.z;
-	rotatedpoint.y = (u.y * u.x * (1 - costheta) + u.z * sintheta) * point.x \
-	+ (costheta + u.y * u.y * (1 - costheta)) * point.y \
-	+ (u.y * u.z * (1 - costheta) - u.x * sintheta) * point.z;
-	rotatedpoint.z = (u.z * u.x * (1 - costheta) - u.y * sintheta) * point.x \
-	+ (u.z * u.y * (1 - costheta) + u.x * sintheta) * point.y \
-	+ (costheta + u.z * u.z * (1 - costheta)) * point.z;
-	return (rotatedpoint);
-}
diff --git a/src/main.c b/src/main.c
index d00e17f..b5054a5 100644
--- a/src/main.c
+++ b/src/main.c
@@ -6,163 +6,344 @@
 /*   By: pedro <pedro@student.42.fr>                +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2023/12/22 18:41:38 by pvital-m          #+#    #+#             */
-/*   Updated: 2024/02/12 21:05:36 by pedro            ###   ########.fr       */
-/*                                                                            */
+/*   Updated: 2024/01/29 18:51:19 by pedro            ###   ########.fr       */
+/*                                                \                            */
 /* ************************************************************************** */
 
 #include "center.h"
 
-gscene	*g_scene = NULL;
+gscene *scene = NULL;
+Vec4 getBackgroundColor(Ray raytrace);
+Vec3 normalCalc(Object *obj, Vec3 p);
 
-int	compcolor(int obj_color, Vec4 objectColor)
+Object *getClosestObject(Ray *rayTrace, double maxDistance, double minDistance, bool updateData)
 {
-	int	r;
-	int	g;
-	int	b;
-
-	r = ((obj_color >> 16 & 255)) * objectColor.r;
-	g = ((obj_color >> 8 & 255)) * objectColor.g;
-	b = ((obj_color & 255)) * objectColor.b;
-	return (newrgb(r, g, b));
+    double ct = INFINITY;
+    Object *closest = NULL;
+    for (Object *lst = scene->objects; lst; lst = lst->next)
+    {
+        rayTrace->val = lst->colision(lst, *rayTrace);
+        if ((rayTrace->val.t0 > minDistance && rayTrace->val.t0 < maxDistance) && rayTrace->val.t0 < ct)
+        {
+            closest = lst;
+            ct = rayTrace->val.t0;
+        }
+        else if ((rayTrace->val.t1 > minDistance && rayTrace->val.t1 < maxDistance) && rayTrace->val.t1 < ct)
+        {
+            closest = lst;
+            ct = rayTrace->val.t1;
+        }
+    }
+    if (updateData)
+    {
+        rayTrace->normal = normalCalc(closest, Add(rayTrace->o, Mul(rayTrace->d, ct)));
+        rayTrace->ct = ct;
+        rayTrace->HitPoint = Add(rayTrace->o, Mul(rayTrace->d, ct));
+    }
+    return closest;
 }
 
-int	utils_ray_color(int lc, int refc, double reflection)
+void calc_combined(Vec4 *combined, int light_color, double brightness)
 {
-	return (
-		newrgb((int)(
-			mulcomp(lc, 16, 1 - reflection) \
-			+ mulcomp(refc, 16, reflection)), \
-			(int)(mulcomp(lc, 8, 1 - reflection) \
-			+ mulcomp(refc, 8, reflection)), \
-			(int)(mulcomp(lc, 0, 1 - reflection) \
-				+ mulcomp(refc, 0, reflection)))
-);
+    combined->r += plusComponent(light_color, 16, brightness) / 255;
+    combined->g += plusComponent(light_color, 8, brightness) / 255;
+    combined->b += plusComponent(light_color, 0, brightness) / 255;
 }
 
-int	raycolor(Ray rayTrace, int depth)
+// p = HITPOINT
+// n = NORMAL
+// v = VIEW
+// d = DEPTH
+
+Vec3 reflect_ray(Vec3 light, Vec3 normal)
 {
-	int		lc;
-	Object	*obj;
-	Vec3	reflected;
-	Ray		refr;
-	int		refc;
-	lc = 0;
-
-	obj = intersections(&rayTrace, INFINITY, 0, true);
-	if (!obj)
-		return (0);
-	if (dot(rayTrace.d, rayTrace.normal) > 0)
-		rayTrace.normal = mul(rayTrace.normal, -1);
-	lc = compcolor(obj->color, calcligh(rayTrace._hit, \
-		rayTrace.normal, rayTrace.d, obj->specular));
-	if (obj->reflection <= 0 || obj->specular <= 0 || depth <= 0)
-		return (lc);
-	reflected = reflect(rayTrace.d, rayTrace.normal);
-	refr = (Ray){.o = add(rayTrace._hit, mul(reflected, 0.001)), .d =
-		reflected};
-	refc = raycolor(refr, depth - 1);
-	lc = newrgb((int)(mulcomp(lc, 16, 1 - obj->reflection)
-				+ mulcomp(refc, 16, obj->reflection)),
-			(int)(mulcomp(lc, 8, 1 - obj->reflection)
-				+ mulcomp(refc, 8, obj->reflection)),
-			(int)(mulcomp(lc, 0, 1 - obj->reflection)
-				+ mulcomp(refc, 0, obj->reflection)));
-	return (lc);
+    Vec3 result;
+
+    double dot_product = normal.x * light.x + normal.y * light.y + normal.z * light.z;
+
+    result.x = light.x - 2 * normal.x * dot_product;
+    result.y = light.y - 2 * normal.y * dot_product;
+    result.z = light.z - 2 * normal.z * dot_product;
+
+    return result;
 }
 
-#include <pthread.h>
+double to_reflect(Vec3 light, Vec3 n, Vec3 vect, Vec3 *reflected)
+{
+    double r_dot_v;
 
-#define NUM_THREADS 12
+    *reflected = reflect_ray(light, n);
+    r_dot_v = reflected->x * vect.x + reflected->y * vect.y + reflected->z * vect.z;
 
-typedef struct {
-    double start_y;
-    double end_y;
-} ThreadData;
+    return r_dot_v;
+}
 
-void* renderFrameThread(void* arg) {
-    ThreadData* data = (ThreadData*)arg;
-    Ray ray;
-    int color;
+double compute_refl(Vec3 data, Vec3 reflected, Vec3 vect)
+{
+    double bright;
+    double length_reflected = sqrt(reflected.x * reflected.x + reflected.y * reflected.y + reflected.z * reflected.z);
+    double length_vect = sqrt(vect.x * vect.x + vect.y * vect.y + vect.z * vect.z);
 
-    for (double y = data->start_y; y > data->end_y; y--) {
-        for (double x = -g_scene->width / 2; x < g_scene->width / 2; x++) {
-            ray = getraydir((g_scene->camera)->o, x, y);
-            color = raycolor(ray, g_scene->depth);
-            my_mlx_pixel_put(tocanvas(x, false), tocanvas(y, true), color);
-        }
-    }
+    bright = data.x * pow(data.y / (length_reflected * length_vect), data.z);
 
-    return NULL;
+    return bright;
 }
 
-void renderFrame(void) {
-    pthread_t threads[NUM_THREADS];
-    ThreadData threadData[NUM_THREADS];
-    double step = g_scene->height / NUM_THREADS;
+void diffusion(Vec4 *combined, Vec3 normal, Vec3 light, Light *src)
+{
+    double n_dot_l;
+    double bright;
 
-    for (int i = 0; i < NUM_THREADS; i++) {
-        threadData[i].start_y = g_scene->height / 2 - i * step;
-        threadData[i].end_y = threadData[i].start_y - step;
-        pthread_create(&threads[i], NULL, renderFrameThread, &threadData[i]);
+    n_dot_l = Dot(normal, light);
+    if (n_dot_l > 0)
+    {
+        bright = src->intensity * n_dot_l /
+                 (Length(normal) * Length(light));
+        calc_combined(combined, src->color, bright);
     }
+}
+
+Vec4 calculateLighting(Vec3 p, Vec3 n, Vec3 v, double spec)
+{
+    Vec4 Combined;  // Combinação de cores
+    double r_dot_v; // Reflexão da luz
+    Light *light;   // Luz
+    Vec3 p_v_l;     // Vetor da luz (ponto - luz)
+    Vec3 reflected; // Reflexão da luz
+
+    Combined = (Vec4){0, 0, 0};
+    light = scene->lights;
+    if (light == NULL)
+        return Combined;
+    while (light)
+    {
+        if (light->type == AMBIENT)
+        {
+            calc_combined(&Combined, light->color, light->intensity);
+            break;
+        }
+        p_v_l = Sub(light->o, p);
+        Ray localSimulation; // Simulação local
+        localSimulation.o = p;
+        localSimulation.d = Normalize(p_v_l);
+        if (getClosestObject(&localSimulation, 1, 0.001, false))
+        {
+            light = (Light *)light->next;
+            continue;
+        }
+        // Calculate diffuse light
+        diffusion(&Combined, n, p_v_l, light);
 
-    for (int i = 0; i < NUM_THREADS; i++) {
-        pthread_join(threads[i], NULL);
+        // Calculate specular light
+        r_dot_v = to_reflect(light->o, n, v, &reflected);
+        if (spec > 0 && r_dot_v > 0)
+        {
+            double light_intensity = light->intensity / (Length(p_v_l) * Length(p_v_l));
+            double brightness = compute_refl((Vec3){light_intensity, r_dot_v, spec}, reflected, v);
+            calc_combined(&Combined, light->color, brightness);
+        }
+        light = (Light *)light->next;
     }
+    if (Combined.r >= 1)
+        Combined.r = 1;
+    if (Combined.g >= 1)
+        Combined.g = 1;
+    if (Combined.b >= 1)
+        Combined.b = 1;
+    return Combined;
+}
+
+Vec4 checkerboardColor(Vec3 point, Vec4 color1, Vec4 color2, double size)
+{
+    if ((int)(floor(point.x / size) + floor(point.y / size) + floor(point.z / size)) % 2 == 0)
+        return color1;
+    else
+        return color2;
+}
 
-    mlx_put_image_to_window(g_scene->mlx->mlx, g_scene->mlx->win, g_scene->mlx->img, 0, 0);
+int computeColor(int obj_color, Vec4 objectColor)
+{
+    int r;
+    int g;
+    int b;
+
+    r = ((obj_color >> 16 & 255)) * objectColor.r;
+    g = ((obj_color >> 8 & 255)) * objectColor.g;
+    b = ((obj_color & 255)) * objectColor.b;
+    return rgbGetter(r, g, b);
+}
+
+int RayColor(Ray rayTrace, int depth)
+{
+    // printf("Raycolor depth: %d\n", depth);
+    int localColor = 0;
+    if (depth < 1)
+        return 0;
+    Object *obj = getClosestObject(&rayTrace, INFINITY, 0, true);
+    if (!obj)
+        return 0;
+    if (Dot(rayTrace.d, rayTrace.normal) > 0)
+        rayTrace.normal = Mul(rayTrace.normal, -1);
+    Vec4 objectColor = calculateLighting(rayTrace.HitPoint, rayTrace.normal, Mul(rayTrace.d, -1), obj->specular);
+    localColor = computeColor(obj->color, objectColor);
+    if(obj->reflection <= 0 || obj->specular <= 0)
+        return localColor;
+    double reflection = obj->reflection;
+    Vec3 reflected = Reflect(rayTrace.d, rayTrace.normal);
+    Ray reflectedRay = (Ray){Add(rayTrace.HitPoint, Mul(reflected, 0.001)), reflected};
+    int reflectedColor = RayColor(reflectedRay, depth - 1);
+    localColor = rgbGetter(
+        (int)(plusComponent(localColor, 16, 1 - reflection) + plusComponent(reflectedColor, 16, reflection)),
+        (int)(plusComponent(localColor, 8, 1 - reflection) + plusComponent(reflectedColor, 8, reflection)),
+        (int)(plusComponent(localColor, 0, 1 - reflection) + plusComponent(reflectedColor, 0, reflection)));
+
+    return localColor;
+}
+
+void renderFrame()
+{
+    for (double y = scene->height / 2; y > -scene->height / 2; y--)
+    {
+        for (double x = -scene->width / 2; x < scene->width / 2; x++)
+        {
+            Ray ray = GetRayDir((scene->camera)->o, x, y);
+            int color = RayColor(ray, 2);
+            my_mlx_pixel_put(toCanvas(x, false), toCanvas(y, true), color);
+        }
+    }
+    mlx_put_image_to_window(scene->mlx->mlx, scene->mlx->win, scene->mlx->img, 0, 0);
     printf("\rDone.\n");
 }
 
-int	sysclean(int res)
+Object *selected = NULL;
+
+#ifdef __APPLE__
+#define UP 126
+#define DOWN 125
+#define LEFT 123
+#define RIGHT 124
+#define ESC 53
+#define W 13
+#define A 0
+#define S 1
+#define D 2
+#define SPACE 49
+#elif __linux__
+#define SPACE 32    // 49
+#define UP 65362    // 126
+#define DOWN 65364  // 125
+#define LEFT 65361  // 123
+#define RIGHT 65363 // 124
+#define ESC 65307   // 53
+#define W 119       // 13
+#define A 97        // 0
+#define S 115       // 1 D // 2
+#define D 100
+#endif
+
+void changeSelector(int keycode)
 {
-	del((Object **)&g_scene->lights);
-	del((Object **)&g_scene->objects);
-	del((Object **)&g_scene->camera);
-	del((Object **)&g_scene->am);
-	free(g_scene);
-	return (res);
+    static int selector = 0;
+
+    if (keycode == SPACE)
+    {
+        selector++;
+        if (selector == 3)
+            selector = 0;
+        printf("Changing Selector %d\n", selector);
+    }
+    if (selector == 0)
+        selected = (Object *)scene->lights;
+    if (selector == 1)
+        selected = scene->objects;
+    if (selector == 2)
+        selected = (Object *)scene->camera;
 }
 
-int key_hook(int keycode, void *param)
+int keyhook(int keycode)
 {
-	printf("Keycode: %d\n", keycode);
-	if (keycode == 53)
-		sysclean(0);
-	if (keycode == 123)
-		g_scene->camera->o.x -= 0.5;
-	if (keycode == 124)
-		g_scene->camera->o.x += 0.5;
-	if (keycode == 125)
-		g_scene->camera->o.y += 0.5;
-	if (keycode == 126)
-		g_scene->camera->o.y -= 0.5;
-	if (keycode == 12)
-		g_scene->camera->o.z += 0.5;
-	if (keycode == 14)
-		g_scene->camera->o.z -= 0.5;
-	renderFrame();
-	return (0);
+    printf("keycode: %d\n", keycode);
+    if (keycode == SPACE || selected == NULL)
+        changeSelector(keycode);
+    if (keycode == UP)
+        selected->o.z += 1;
+    if (keycode == DOWN)
+        selected->o.z -= 1;
+    if (keycode == LEFT)
+        selected->o.x -= 1;
+    if (keycode == RIGHT)
+        selected->o.x += 1;
+    if (keycode == W)
+        selected->o.y += 1;
+    if (keycode == S)
+        selected->o.y -= 1;
+    if (keycode == ESC)
+    {
+        mlx_clear_window(scene->mlx->mlx, scene->mlx->win);
+        mlx_destroy_window(scene->mlx->mlx, scene->mlx->win);
+        mlx_destroy_image(scene->mlx->mlx, scene->mlx->img);
+#ifndef __APPLE__
+        mlx_destroy_display(scene->mlx->mlx);
+#endif
+        free(scene->mlx->mlx);
+        free(scene->mlx);
+        exit(0);
+    }
+    if (keycode == SPACE || keycode == UP || keycode == DOWN || keycode == LEFT || keycode == RIGHT || keycode == W || keycode == S)
+        renderFrame();
+    return 0;
 }
 
-int	main(int argc, char **argv)
+int main(void)
 {
-	g_scene = init_main(1000, 1000, 16);
-	if (!g_scene)
-		return (1);
-	if (argc != 2)
-		return (1);
-	g_scene = init_main(1000, 500, 2);
-	if (!g_scene)
-		return (sysclean(1));
-	if ((!parse(argv[1])))
-		return (sysclean(1));
-	if (!g_scene->am || !g_scene->camera || g_scene->error)
-		return (sysclean(1));
-	if (!initialize_mlx(g_scene))
-		return (sysclean(1));
-	renderFrame();
-	mlx_key_hook(g_scene->mlx->win, key_hook, NULL);
-	mlx_loop(g_scene->mlx->mlx);
-	return (0);
+    scene = init_MainStruct(1000, 1000);
+    if (!scene)
+        return 1;
+
+    objectAdd(
+        (Object *)newCamera(
+            (Vec3){0, 0, -5},
+            (Vec3){0, 0, 0},
+            53.3,
+            (Vec3){0, 0, 0}),
+        (Object **)&scene->camera);
+    objectAdd((Object *)newSphere((Vec3){0, 0, 0}, (Vec3){0, 0, 0}, (Vec4){0, 255, 0}, (Vec3){0, 0, 0}, 1, sphereColision, 0.8, 32), (Object **)&scene->objects);
+    // objectAdd((Object *)newSphere((Vec3){1, 0, 1}, (Vec3){0, 0, 0}, (Vec4){255, 0, 255}, (Vec3){0, 0, 0}, 1, sphereColision, 0, 32), (Object **)&scene->objects);
+    objectAdd((Object *)newLight((Vec3){-1, 0, -5}, (Vec3){0, 2, 0}, (Vec4){0, 255, 0}, (Vec3){0, 0, 0}, 1, POINT), (Object **)&scene->lights);
+    // objectAdd((Object *)newLight((Vec3){1, 0, -5}, (Vec3){0, 0, 0}, (Vec4){0, 255, 0}, (Vec3){0, 0, 0}, 0.5, POINT), (Object **)&scene->lights);
+    // objectAdd((Object *)newLight((Vec3){1, 0, -5}, (Vec3){0, 0, 0}, (Vec4){255, 255, 255}, (Vec3){0, 0, 0}, 0.2, AMBIENT), (Object **)&scene->lights);
+    objectAdd((Object *)newPlane((Vec3){0, -1, 0}, (Vec3){0, 1, 0}, (Vec4){255, 255, 255}, (Vec3){0, 0, 0}, 1, planeColision, 0, 0, 0), (Object **)&scene->objects);
+
+    renderFrame();
+    mlx_key_hook(scene->mlx->win, keyhook, scene->mlx);
+    // mlx_loop_hook(scene->mlx->mlx, keyhook, NULL);
+    mlx_loop(scene->mlx->mlx);
+    return 0;
 }
+
+/*
+
+    UPDATES:
+
+
+        All the colors object are now in format int:
+
+        Functions Created:
+            -> int rgbGetter(int r, int g, int b)                                   mlx/utils.c
+            -> double plusComponent(int color, int shifting, double intensity)      mlx/utils.c
+            -> int convertLightColor(int color, double intensity)                   mlx/utils.c
+            -> void blend(Vec4 *a, int lightColor, double brightness)               main.c
+
+        Functions Updated:
+            -> newObject(size_t ModelType, Vec3 o, Vec3 d, Vec4 color, Vec3 theta)  Objects/Create.c
+
+
+        Functions Updated:
+            -> Vec4 RayColor(Ray rayTrace, int depth)                               main.c
+            -> Vec4 calculateLighting(Vec3 p, Vec3 n, Vec3 v, double depth)         main.c
+            -> Vec4 RayColor(Ray rayTrace, int depth
+
+        Reason:
+            Losing information. The colors are now in int format, so we can use the bitwise operations to get the colors and the intensity of the light.
+            ITS MOR EASY TO WORK WITH INTS THAN WITH VECTORS
+*/
diff --git a/src/mlx/utils.c b/src/mlx/utils.c
index 792600d..a0c0a0d 100644
--- a/src/mlx/utils.c
+++ b/src/mlx/utils.c
@@ -1,74 +1,32 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   utils.c                                            :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: psoares- <psoares-@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/05 21:48:47 by pedro             #+#    #+#             */
-/*   Updated: 2024/02/10 17:35:44 by psoares-         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
 #include <center.h>
 
-/// @brief Create a new color
-/// @param r  The red component of the color
-/// @param g  The green component of the color
-/// @param b  The blue component of the color
-/// @return The new color
-int	newrgb(int r, int g, int b)
+//Accept 3 integers and return a single integer with the RGB value
+int rgbGetter(int r, int g, int b)
 {
 	return (r << 16 | g << 8 | b);
 }
 
-/// @brief Multiply a color component by an intensity
-/// @param color  The color to be modified
-/// @param shifting  The shifting of the color
-/// @param intensity  The intensity to be multiplied
-/// @return The new value of the color
-double	mulcomp(int color, int shifting, double intensity)
+
+//Accepts a color, a shifting value, and an intensity value, and returns the new value of the color
+double plusComponent(int color, int shifting, double intensity)
 {
 	return ((color >> shifting & 255) * intensity);
 }
 
-/// @brief Multiply a color by an intensity
-/// @param color  The color to be modified
-/// @param intensity  The intensity to be multiplied
-/// @return The new value of the color
-int	colmul(int color, double intensity)
-{
-	int	r;
-	int	g;
-	int	b;
-
-	r = ((color >> 16 & 255)) * intensity;
-	g = ((color >> 8 & 255)) * intensity;
-	b = ((color >> 0 & 255)) * intensity;
-	return (newrgb(r, g, b));
+//Accepts a color and an intensity value, and returns the new value of the color
+int colorMultiply(int color, double intensity){
+	int r = plusComponent(color, 16, intensity);
+	int g = plusComponent(color, 8, intensity);
+	int b = plusComponent(color, 0, intensity);
+	return rgbGetter(r, g, b);
 }
 
-/// @brief Put a pixel in the screen
-/// @param x  The x coordinate of the pixel
-/// @param y  The y coordinate of the pixel
-/// @param rgb  The color of the pixel
+//Accepts a color and an intensity value, and returns the new value of the color
 void	my_mlx_pixel_put(double x, double y, int rgb)
 {
 	char	*dst;
 
-	dst = g_scene->mlx->addr + (((int)y) * \
-		g_scene->mlx->line_length + ((int)x) * \
-		(g_scene->mlx->bits_per_pixel / 8));
+	dst = scene->mlx->addr + (((int)y) * scene->mlx->line_length + ((int)x) * (scene->mlx->bits_per_pixel/ 8));
 	*(unsigned int *)dst = rgb;
 }
 
-/// @brief Convert a coordinate to the canvas
-/// @param combined  The combined color
-/// @param light_color  The color of the light
-/// @param brightness The brightness of the light
-void calc_combined(Vec4 *combined, int light_color, double brightness)
- {
-	combined->r += mulcomp(light_color, 16, brightness) / 255;
-	combined->g += mulcomp(light_color, 8, brightness) / 255;
-	combined->b += mulcomp(light_color, 0, brightness) / 255;
-}
\ No newline at end of file
diff --git a/src/normalcalc.c b/src/normalcalc.c
deleted file mode 100644
index af32852..0000000
--- a/src/normalcalc.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   normalcalc.c                                       :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: psoares- <psoares-@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2024/02/08 01:01:58 by psoares-          #+#    #+#             */
-/*   Updated: 2024/02/10 19:01:23 by psoares-         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include <center.h>
-
-static	Vec3	normalcalcutilsone(Object *obj, Vec3 p)
-{
-	Vec3	normal;
-
-	normal = (Vec3){0, 0, 0};
-	if (!obj)
-		return (normal);
-	if (obj->type == SPHERE)
-	{
-		normal = sub(p, (obj)->o);
-		normal = norm(normal);
-	}
-	else if (obj->type == PLANE)
-		normal = ((Plane *)obj)->d;
-	return (normal);
-}
-
-static	Vec3	normalcalccylinder(Object *obj, Vec3 p)
-{
-	Vec3		normal;
-	Cylinder	*c;
-	Vec3		oc;
-	double		t;
-
-	normal = (Vec3){0, 0, 0};
-	if (!obj || obj->type != CYLINDER)
-		return (normal);
-	c = (Cylinder *)obj;
-	oc = sub(p, c->o);
-	t = dot(oc, c->d);
-	if (t < 0.001 || t > c->height - 0.001)
-		normal = (c->d);
-	else
-	{
-		normal = sub(oc, mul(c->d, t));
-		normal = norm(normal);
-	}
-	return (normal);
-}
-
-static	Vec3	normalcalcParaboloid(Object *obj, Vec3 p)
-{
-    Vec3		normal;
-    Paraboloid	*paraboloid;
-    Vec3		op;
-
-    normal = (Vec3){0, 0, 0};
-    if (!obj || obj->type != PARABOLOID)
-        return (normal);
-    paraboloid = (Paraboloid *)obj;
-    op = sub(p, paraboloid->o);
-    normal = (Vec3){2 * op.x, 2 * op.y, -1};
-    normal = norm(normal);
-    return (normal);
-}
-
-Vec3	normalcalc(Object *obj, Vec3 p)
-{
-	Vec3	normal;
-
-	normal = normalcalcutilsone(obj, p);
-	if (normal.x == 0 && normal.y == 0 && normal.z == 0)
-		normal = normalcalccylinder(obj, p);
-	if (normal.x == 0 && normal.y == 0 && normal.z == 0)
-		normal = normalcalcParaboloid(obj, p);
-	return (normal);
-}
